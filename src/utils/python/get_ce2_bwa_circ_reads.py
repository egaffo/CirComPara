#!/usr/bin/env python

import os, sys, argparse, gzip, pysam
from collections import defaultdict
from itertools import groupby

'''
These are modfied from the BWA parse function of CIRCexplorer2
https://github.com/YangLab/CIRCexplorer2/blob/master/circ2/parse.py
Modified: Enrico Gaffo (enrico.gaffo@unipd.it)
'''

class Segment(object):
    '''
    Modified from https://github.com/brentp/cigar
    '''
    def __init__(self, pos, cigar):
        self.ref_start = int(pos) - 1
        self.ref_end = self.ref_start
        read_consuming_ops = ("M", "I")
        ref_consuming_ops = ("M", "D")
        cig_iter = groupby(cigar, lambda c: c.isdigit())
        self.read_start, self.read_end = 0, 0
        for i, (g, n) in enumerate(cig_iter):
            counts, tag = int("".join(n)), "".join(next(cig_iter)[1])
            if i == 0 and tag == 'S':
                self.read_start += counts
                self.read_end += counts
            if tag in read_consuming_ops:
                self.read_end += counts
            if tag in ref_consuming_ops:
                self.ref_end += counts


def bwa_parse(fusion, out):

    fusions = defaultdict(int)
    samFile = pysam.AlignmentFile(fusion, 'r')
    for read in samFile:
        if read.is_unmapped:  # unmapped reads
            continue
        if read.is_supplementary:  # supplementary reads
            continue
        if not read.has_tag('SA'):  # no SA tag
            continue
        chr1 = samFile.get_reference_name(read.reference_id)
        strand1 = '+' if not read.is_reverse else '-'
        saInfo = read.get_tag('SA').split(';')[:-1]
        loc = [read.query_alignment_start, read.query_alignment_end,
               read.reference_start, read.reference_end]
        segments = [loc]
        for sa in saInfo:
            chr2, pos, strand2, cigar = sa.split(',')[:4]
            if chr1 != chr2:  # not same chromosome
                continue
            if strand1 != strand2:  # not same strand
                continue
            segment = Segment(pos=pos, cigar=cigar)
            segments.append([segment.read_start, segment.read_end,
                             segment.ref_start, segment.ref_end])
        segments.sort()
        cov_loc = segments[0][1]
        ref_loc = segments[0][3]
        bflag = 0
        cigar_l, cigar_r = 0, 0
        ref_l, ref_r = 0, 0
        for s in segments[1:]:
            if s[2] < ref_loc and s[0] <= cov_loc:
                bflag += 1
                cigar_l = s[0]
                cigar_r = cov_loc
                ref_l = s[2]
                ref_r = ref_loc
            cov_loc = s[1]
            ref_loc = s[3]
        if bflag == 1:
            fusion_left = str(ref_l)
            fusion_right = str(ref_r - (cigar_r - cigar_l))
            fusion_loc = '\t'.join([chr1, fusion_left, fusion_right])
            #fusions[fusion_loc] += 1
            print '\t'.join([fusion_loc, read.query_name, '1' if read.is_read1 else '2', strand1])
    samFile.close()
    #total = 0
    #with open(out, 'w') as outF:
    #    for i, pos in enumerate(fusions):
    #        outF.write('%s\tFUSIONJUNC_%d/%d\t0\t+\n' % (pos, i, fusions[pos]))
    #        total += fusions[pos]
    #print('Converted %d fusion reads!' % total)

if __name__ == '__main__':

    usage = """
           Extract backspliced reads, according to CIRCexplorer2 parse, from SAM file generated by BWA, and output into BED coordinates (field 5 represent the read mate). Output in stdout.
            """

    parser = argparse.ArgumentParser(description = usage, 
                                     formatter_class = argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('-i', '--infilename', default = '-', required = True,
                        help = 'bwa_out/RS4_11_bwa.sam. The BWA SAM output.')
    args = parser.parse_args()


    if args.infilename == '-':
        junc_f = sys.stdin
    else:
        junc_f = open(args.infilename, 'r')
    
    bwa_parse(junc_f, None)
