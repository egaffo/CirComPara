---
title: "CirComPara: detection and analysis of circular RNAs"
date: "`r Sys.Date()`"  
output: 
  html_document: 
    keep_md: no
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: 
      collapsed: false
      smooth_scroll: true
    theme: "readable"
---

# CirComPara results summary

CirComPara analysis results are presented in this page. Different sections display aggregated data in tables and figures. Raw and integrated results were saved in comma separated (CSV) files. 

```{r global_options, include=FALSE}
## variables to be defined in parent frame
# circrnas.gtf.file
# circ_to_genes.file
# gene_to_circ.file
# ccp_circrna_raw_xpr.csv.file
# bks_linear_counts.tab.gz.file
# meta_file
# vars.py.filepath
# ccp_circrna_methods.csv.file
# ccp_circrna_n_methods.csv.file
# min_methods
# min_reads

dir.create(path = results.dir, showWarnings = F, recursive = T)
knitr::opts_chunk$set(fig.width = 6, 
                      fig.height = 4, 
                      dev = c('svglite', 'png'), 
                      fig.pos = "center",
                      fig.path = file.path(results.dir, paste0('Figs', .Platform$file.sep)),
                      echo = FALSE, 
                      warning = FALSE, 
                      message = FALSE)
library(knitr)
library(data.table)
library(ggplot2)
library(RColorBrewer)
library(scales)
library(DT)
library(pheatmap)
library(viridis)
library(DESeq2)
```


```{r utility_functions, echo=FALSE, include=FALSE}
# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)
  
  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)
  
  numPlots = length(plots)
  
  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }
  
  if (numPlots==1) {
    print(plots[[1]])
    
  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    
    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
      
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

# Compute label for a circRNA according to gene overlaps
#
# This function serves to categorize backsplices according to the positions
# relative to gene/exons.
# An "error region" of the exon/backsplice coordinates could be considered
# by setting flank > 0
# We define three backsplice categories:
# 1. Intergenic: both start and end are outside any gene
# 2. Intronic: both end are in intron(s)
# 3. Exonic: either start or end is in exon(s)
#
# - backsplice: a two elements integer array with start and end of the circRNA
# - exon:       a two elements integer array with start and end of the exon
# - gene:       a two elements integer array with start and end of the gene
# - flank:      the number of flanking bases allowed for the backspice coordinates
#
label.backsplice <- function(backsplice, exon, gene, flank = 0){
  
  gene_start <- gene[1] - flank
  gene_end <- gene[2] + flank
  exon_start <- exon[1] - flank
  exon_end <- exon[2] + flank
  circ_start <- backsplice[1]
  circ_end <- backsplice[2]
  
  category <- "undefined"
  if(exon_start < 0){
    category <- "intergenic"
  }else{
    if(circ_start >= gene_start | circ_end <= gene_end){ # are we inside a gene?
      category <- "intronic"
      if(circ_start >= exon_start | circ_end <= exon_end){ # are we within an exon?
        category <- "exonic"
      }
    }else{
      # we are not inside a gene, but an exon is overlapped
      if(circ_start < gene_start & circ_end > gene_end){ # just double check we are completely outside a gene
        category <- "intergenic_spanning_gene"
      }
    }
  }
  category
}

# Refine labelling for a circRNA
#
# - labels_list: the list of labels assigned to i circRNA ID
#
refine_label <- function(labels_list){
  
  if("exonic" %in% labels_list){
    label <- "exonic"
  }else{
    if("intronic" %in% labels_list){
      label <- "intronic"
    }else{
      if("intergenic" %in% labels_list){
        label <- "intergenic"
      }else{
        label <- paste0(sort(unique(labels_list)), collapse = ",")
      }
    }
  }
  label
}

# reduce complexity of labels. Simplify into exonic, intronic, intergenic 
# categories. The function simply assign "exonic" if at least one exon 
# overlaps the backsplice; otherwise, "intron" if an intron overlaps; 
# otherwise, "intergenic" for either intergenic and intergenic_spanning_gene;
# "other" as a backfall label that should not appear.
# - label: the collapsed labels for a circRNA
simplify_circrna_labels <- function(label){
    lab <- "other"
    if(grepl("exon", label)){
        lab <- "exonic"
    }else{
        if(grepl("intergenic", label)){
            lab <- "intergenic"
        }
        if(grepl("intron", label)){
            lab <- "intronic"
        }
    }
    lab
}
```

```{r set custom color shades}
## set custom color shades
## function to compute color hues and colors to give to each sample
get.color.hues <- function(meta){
    intgroup.dt <- meta[, .(.N), by = .(sample_id, 
                                        condition)][order(sample_id), 
                                                    .(sample_id), by = condition]
    
    samples.per.condition <- data.frame(intgroup.dt[, .N, by = .(condition)])
    rownames(samples.per.condition) <- as.character(samples.per.condition$condition)
    samples.per.condition$condition <- NULL
    n.conditions <- nrow(samples.per.condition)
    hues <- brewer_pal(palette = "Set2")(n.conditions)
    
    if(nrow(intgroup.dt) == 1){
        intgroup.dt[, `:=`(color = hues[1],  hue = hues[1])]
    }else{
        for(i in 1:n.conditions){
            n.hues <- samples.per.condition[i, "N"] + 2
            col.hues <- colorRampPalette(colors = c(hues[i], 
                                                    "white"))(n.hues)[1:(n.hues-2)]
            
            intgroup.dt[condition == rownames(samples.per.condition)[i], `:=`(color = col.hues,
                                                                              hue = hues[i])]
        }
    }
    intgroup.dt[]
}
```

```{r}
vars.to.df <- function(vars.py.filepath){
    vars <- readChar(vars.py.filepath, nchars = file.info(vars.py.filepath)$size)
    ## revert multi-line strings into one-line and remove all blank chars
    a <- gsub(" ", "", gsub("['\"]\\\\[ ]*\n[ ]*['\"]", "", vars))
    ## set multi-line vector values into one-line
    b <- gsub(",[ ]*\n", ",", a)
    b <- gsub(",#.*\n'", ",'", b)
    ## skip comment lines
    c <- grep(pattern = "^#", invert = T, 
              x = strsplit(b, "\n", fixed = T)[[1]], 
              value = T)
    ## skip blank lines
    d <- paste0(c[c != ""], collapse = "\n")
    ## transform into a data.frame
    vars.df <- data.table(read.table(text = d, sep = "=", header = F, stringsAsFactors = F))
    colnames(vars.df) <- c("Variable", "Value")
    # rownames(vars.df) <- as.character(vars.df$Variable) ## TODO: handle duplicated parameters
    vars.df
}
```


```{r, echo=FALSE}
if(meta_file != ""){
    if(!"sample" %in% colnames(fread(meta_file))){
        ## merge meta.csv file list
        meta <- rbindlist(lapply(readLines(meta_file), fread), 
                          use.names = T, fill = T)
    }else{
        ## single meta.csv file
        meta <- fread(meta_file)
    }
    meta <- unique(meta[, .(sample_id = sample, condition)])
    intgroup.dt <- get.color.hues(meta)
}
```

```{r}
## save datasets design matrix
meta.file.out <- file.path(results.dir, "sample_conditions.csv")
fwrite(x = meta, file = meta.file.out, row.names = F)
```

Samples' metadata have been saved in file <a href="`r basename(meta.file.out)`">`r basename(meta.file.out)`</a>.  

```{r}
circrna.rpms <- fread(ccp_circrna_raw_xpr.csv.file, showProgress = F)
exists_circrnas <- F
if(nrow(circrna.rpms) > 0) exists_circrnas <- T
```


```{r load_circrna_gene_overlaps, echo=FALSE, include=FALSE}
## retrieve and attach gene symbols and gene_ids
circ_to_genes <- fread(circ_to_genes.file)
if(ncol(circ_to_genes) == 1){
    ## case: text file listing circ_to_genes.csv files
    circ_to_genes <- unique(rbindlist(lapply(readLines(circ_to_genes.file), fread)))
    
    ## intergenic clusters can have different names for different runs of CCP,
    ## we must merge them: re-run intergenic circrna clustering
    intergenic_circs <- circ_to_genes[simple_gene_region == "intergenic"]
    intergenic_circs[, c("chr", "coords"):=tstrsplit(circ_id, ":")]
    intergenic_circs[, c("start", "end"):=tstrsplit(coords, "-", type.convert = T)]
    
    suppressPackageStartupMessages(library(bedr))
    
    circ.clusters <- 
        data.table(cluster.region(unique(intergenic_circs[order(chr, start), 
                                                          circ_id]),
                                  distance = 5000,
                                  check.chr = F, 
                                  verbose = F))[, .(circ_id = index, 
                                                    cluster = regionIndex)]
    
    intergenic_circs_clust <- 
        merge(intergenic_circs,
              circ.clusters, 
              by = "circ_id")[, gene_names := paste0("CircClust", "_",
                                                     chr, ":", min(start),
                                                     "-", max(end)),
                              by = cluster][, colnames(circ_to_genes), with = F]
    
    circ_to_genes <- 
        rbindlist(list(circ_to_genes[simple_gene_region != "intergenic"],
                       unique(intergenic_circs_clust)), 
                  use.names = T)
}

exists_gene_overlaps <- FALSE
if(nrow(circ_to_genes) > 0){
    exists_gene_overlaps <- TRUE
}
```

```{r}
## save merged host gene annotation
merged.circ.to.genes.file <- file.path(results.dir, "circ_to_genes.csv")
fwrite(circ_to_genes, merged.circ.to.genes.file, row.names = F)
```

CircRNA host gene annotation (one row per circRNA) was saved in <a href="`r basename(merged.circ.to.genes.file)`">`r basename(merged.circ.to.genes.file)`</a>.  

```{r}
circ_to_gene <- fread(gene_to_circ.file)
if(ncol(circ_to_gene) == 1){
    ## case: text file listing gene_to_circ.csv files
    circ_to_gene <- unique(rbindlist(lapply(readLines(gene_to_circ.file), fread)))
    
    ## use intergenic clusters defined from the circ_to_genes list
    circ_to_gene <- 
        unique(rbindlist(list(circ_to_gene[gene_region != "intergenic"],
                              intergenic_circs_clust[, .(circ_id,
                                                         strand,
                                                         gene_region,
                                                         simple_gene_region,
                                                         gene_strand,
                                                         gene_id = gene_ids,
                                                         gene_name = gene_names,
                                                         gene_biotype = gene_biotypes)]), 
                         use.names = T))
    
}
```

```{r}
## save merged host gene annotation
merged.circ.to.gene.file <- file.path(results.dir, "gene_to_circ.csv")
fwrite(circ_to_gene, merged.circ.to.gene.file, row.names = F)
```

Genes expressing circRNAs are listed in <a href="`r basename(merged.circ.to.gene.file)`">`r basename(merged.circ.to.gene.file)`</a>.  

```{r}
if(exists_circrnas & exists_gene_overlaps){
  setkey(circrna.rpms, circ_id)
  setkey(circ_to_genes, circ_id)
  circrna.rpms.genes <- circ_to_genes[circrna.rpms]
}else{
  sample.table.file.names <- "No circRNAs or no known genes overalp"
}
```

```{r}
## read vars.py file and parse the text
vars <- readChar(vars.py.filepath, nchars = file.info(vars.py.filepath)$size)
if(!grepl("=", vars)){
    ## merge vars.py files
    vars <- rbindlist(lapply(readLines(vars.py.filepath), 
                     function(x)as.data.table(vars.to.df(x))), 
                     use.names = T)
    vars.df <- vars[, lapply(.SD, function(x)paste0(unique(x), collapse = ",")), 
                    by = Variable]
}else{
    vars.df <- vars.to.df(vars.py.filepath)
}
```

```{r}
if(any("CIRCRNA_METHODS" == vars.df$Variable)){
    methods <- unique(strsplit(vars.df[Variable == "CIRCRNA_METHODS", Value], 
                        ",", fixed = T)[[1]])
}else{
    ## CIRCRNA_METHODS maybe not overriden in vars.py, for instance 
    ## when default value is left
    methods <- circrnas.gtf[, unique(method)]
}
```

Backsplices were detected by `r length(unique(methods))` different methods: `r paste0(sort(methods), collapse = ", ")`

```{r reliable_circrnas, echo=FALSE, include=TRUE}
############# CircRNA expression per sample ###########
## get the list of circRNAs detected by min_methods or more methods
circrnas.morethan2methods.medrpm.table <- circrna.rpms.genes[reliable.circrna == 1]
circrnas.morethan2methods.medrpm.table[, `:=`(reliable.circrna = NULL, 
                                              gene_region = simple_gene_region,
                                              simple_gene_region = NULL,
                                              gene_strand = NULL)]
## save table
circRNA_expression_per_sample.csv.basename <- "circRNA_expression_per_sample.csv"
write.csv(x = circrnas.morethan2methods.medrpm.table, 
          file = file.path(results.dir, circRNA_expression_per_sample.csv.basename), 
          row.names = F)
```

## CircRNAs detected per method

Select only circRNAs detected with >= `r min_reads` reads.  

```{r}
circrnas.gtf <- fread(circrnas.gtf.file, showProgress = F)
```

```{r, echo=FALSE, include=TRUE}
## Given that min_reads = 2, select only circRNAs with >= 2 reads 
## (not normalized values) by at least one method. 

detected_circ_ids <- circrnas.gtf[reads >= min_reads, unique(circ_id)]
circ.per.method <- circrnas.gtf[reads >= min_reads,
                                .N, by = .(circ_id, method)]

non.redundant <- circ.per.method[, .N, by = circ_id][, .N]
## number of circRNAs per method
datatable(rbind(circ.per.method[, .("Tot circRNAs" = .N), 
                            by = .(Method = method)][order(-`Tot circRNAs`), ], 
            list("Non-redundant", non.redundant)),
          rownames = F)
```


```{r}
############# Barplot number of circRNAs per methods (sum over all samples) ###########
default.font.size <- 12

lev.order <- circ.per.method[, .N, by = method][order(N), as.character(method)]
circ.per.method$method <- factor(circ.per.method$method, 
                                 levels = lev.order, ordered = T)

ggplot(data = circ.per.method, mapping = aes(x = method, fill = method)) + 
    geom_bar(width = .7, colour = "black") + 
    geom_text(stat = 'count', aes(label = ..count..), vjust = -0.3,
              size = default.font.size*(5/14)) + 
    geom_text(stat = 'count', aes(label = "", y = ..count..*1.1), vjust = -0.3,
              size = default.font.size*(5/14)) + 
    scale_y_continuous(expand = c(0, 0)) + 
    scale_fill_brewer(palette = "Spectral", direction = -1, guide = F) +
    xlab(NULL) + 
    ylab("CircRNAs") +
    ggtitle(bquote("CircRNAs detected with " >= .(min_reads) ~ "reads by each method")) + 
    theme_bw() + 
    theme(text = element_text(size = default.font.size), 
          plot.title = element_text(hjust = 0.5),
          axis.text.x = element_text(angle = 45, hjust = 1))
```

### CircRNAs shared by methods

```{r show_circrnas_shared, echo=FALSE, include=TRUE}
############# Matrix of methods' shared circRNA counts ###########

shared.counts.table <- crossprod(x = table(circ.per.method[, .(circ_id, method)]))
## order rows and columns alphabetically
shared.counts.table <- 
    shared.counts.table[sort(colnames(shared.counts.table)), 
                        sort(colnames(shared.counts.table))]

## save table
# write.csv(x = data.frame(shared.counts.table), 
#           file = file.path(results.dir, "methods_shared_circRNA_counts.csv"), 
#           row.names = F)

kshow <- data.table(shared.counts.table, keep.rownames = "Method")
colnames(kshow) <- sub("_", " ", colnames(kshow))
kshow[, Method := sub("_", " ", Method)]
datatable(kshow, caption = "", rownames = F)
```

```{r, echo=FALSE, include=TRUE, fig.height = 6}
if(nrow(shared.counts.table) > 2){
    pheatmap(log2(as.matrix(shared.counts.table)+1),
             cellwidth = 20, cellheight = 20,
             color = viridis(255),
             cluster_rows = F, 
             cluster_cols = F,
             main = "Shared # circRNAs (log2 scale)")
}
```

```{r, echo=FALSE, include=TRUE}
############# Barplot number of circRNAs shared by methods ###########
## "\u2265" is the unicode character for 'greater than or equal'
# plot.dt <- circ.per.method[, .(shared_by = .N), 
#                                   by = circ_id]

plot.dt <-  
    circrnas.gtf[reads >= min_reads,
                 .(n_methods = .N),
                 by = .(sample_id, 
                        circ_id)][, .(shared_by = max(n_methods)), 
                                  by = circ_id]

ggplot(data = plot.dt, 
       mapping = aes(x = factor(shared_by), 
                     fill = factor(shared_by))) + 
    geom_bar(width = .7, color = "black") + 
    geom_text(stat = 'count', aes(label = ..count..), vjust = -0.3, 
              size = default.font.size*(5/14)) + 
    geom_text(stat = 'count', aes(label = "", y = ..count..*1.1), vjust = -0.3, 
              size = default.font.size*(5/14)) + 
    scale_y_continuous(expand = c(0, 0)) + 
    scale_fill_brewer(direction = 1, guide = F) + 
    xlab("Sharing methods") + 
    ylab("CircRNAs") +
    ggtitle(paste("CircRNAs commonly detected by methods")) +
    theme_bw() + 
    theme(text = element_text(size = default.font.size), 
          plot.title = element_text(hjust = 0.5))
```

```{r, fig.width=3}
# ggplot(data = circ.per.method[, .(shared_by = .N), 
#                               by = circ_id][, .N, by = shared_by], 
ggplot(data = plot.dt[, .N, by = shared_by], 
       mapping = aes(x = "", y = N,
                     fill = factor(shared_by))) + 
    geom_bar(stat = "identity", width = .7, 
             color = "black", position = position_stack(reverse = T)) + 
    geom_text(stat='identity', aes(label=percent(N/sum(N))),
              position = position_stack(vjust = .5, reverse = T)) +
    scale_fill_brewer("# methods", direction = 1, palette = "Greens") +
    scale_y_continuous(expand = c(0, 0)) +
    scale_x_discrete(expand = c(0, 0)) +
    ylab("CircRNAs") +
    xlab(NULL) +
    ggtitle("Proportions of commonly\ndetected circRNAs") +
    # coord_polar(theta = "y") +
    theme_bw() +
    theme(axis.ticks.x = element_blank(), plot.title = element_text(hjust = .5))
```

```{r}
## cumulative number of circrnas by number of methods
# cum.met <- 
#     circ.per.method[, .(n_methods = .N), 
#                     by = circ_id][, .N, 
#                                   by = n_methods][order(-n_methods)][
#                                       , .(n_methods, cum.sum = cumsum(N))]

cum.met <- 
    plot.dt[, .N, by = .(n_methods = shared_by)][order(-n_methods)][
                                      , .(n_methods, cum.sum = cumsum(N))]

ggplot(cum.met, aes(x = factor(paste0("\u2265", n_methods)), 
                    y = cum.sum, fill = factor(paste0("\u2265", n_methods)))) + 
    geom_col(color = "black") +
    geom_text(aes(label = cum.sum), vjust = -.5) +
    geom_text(label = "", aes(y = cum.sum*1.1)) +
    scale_y_continuous(expand = c(0, 0)) +
    scale_fill_brewer(guide = F, palette = "Reds") +
    xlab("Number of methods") +
    ylab("CircRNAs") +
    ggtitle("Cumulative detections") +
    theme_bw() +
    theme(plot.title = element_text(hjust = .5))
```

```{r}
# ## save methods detecting each circRNA
# cmet_per_circ.file <- file.path(results.dir, "cmet_per_circ.csv")
# 
# circ_met <- fread(ccp_circrna_methods.csv.file, showProgress = F)
# circ_met[, pass_min_reads_filter := 0]
# circ_met[circ_id %in% detected_circ_ids, pass_min_reads_filter := 1]
# 
# circ_n_met <- fread(ccp_circrna_n_methods.csv.file, showProgress = F)
# 
# ## attach a column that tells how many methods (at max among the samples)
# ## detected the circrna with >= min_reads. Other columns in circ_n_met count
# ## a method if it detected the circrna with at least 1 read
# circ_n_met <- 
#     merge(circ_n_met,
#           circrnas.gtf[reads >= min_reads,
#                        .(n_methods = .N),
#                        by = .(sample_id, 
#                               circ_id)][, .(max.methods.w.min.reads = max(n_methods)), 
#                                         by = circ_id], 
#           by = c("circ_id"), all.x = T)
# 
# circ_met <- 
#     merge(circ_n_met[, .(circ_id, reliable.circrna, overall.n.methods, max.methods.w.min.reads)],
#           circ_met[, .(circ_id, reliable.circrna, pass_min_reads_filter, overall.circ.methods)], 
#           by = c("circ_id", "reliable.circrna"))[order(-reliable.circrna,
#                                                        -pass_min_reads_filter,
#                                                        -overall.n.methods)]
# 
# write.csv(circ_met, cmet_per_circ.file, row.names = F)
```

```{r}
# analize which is the most numerous combination of methods
reduce.cmeth.names <- function(x){
    x <- gsub("circexplorer2", "ce2", x)
    x <- gsub("segemehl", "se", x)
    x <- gsub("tophat", "th", x)
    x
}

# circ_met.to.plot <-
#     circ_met[circ_id %in% unique(circ.per.method$circ_id),
#              .(circ_id, n_methods = overall.n.methods,
#                c_methods = reduce.cmeth.names(overall.circ.methods))]

circ_met.to.plot <-
    circrnas.gtf[reads >= min_reads,
                 .(n_methods = .N, 
                   c_methods = reduce.cmeth.names(paste0(sort(unique(method)), 
                                                         collapse = "|"))),
                 by = .(sample_id, 
                        circ_id)][, .N, 
                                  by = .(circ_id, n_methods, c_methods)]

circ_met.plot.height <- max(c(4, (circ_met.to.plot[, .N, by = c_methods][, .N]*0.5)/2.54))

circ_met.to.plot <-
    circ_met.to.plot[, .N,
                     by = .(c_methods,
                            n_methods)][order(-N)]

circ_met.to.plot$c_methods <-
    factor(circ_met.to.plot$c_methods,
           levels = circ_met.to.plot$c_methods,
           ordered = T)
```

```{r}
## save methods detecting each circRNA
cmet_per_circ.file <- file.path(results.dir, "cmet_per_circ.csv")
write.csv(circ_met.to.plot, cmet_per_circ.file, row.names = F)
```

Methods detecting each circRNAs are listed in  <a href="`r basename(cmet_per_circ.file)`">`r basename(cmet_per_circ.file)`</a>.

```{r, fig.height=`circ_met.plot.height`, fig.width=7}
## method combinations plot
ggplot(circ_met.to.plot, aes(x = c_methods, y = N)) +
    geom_bar(stat = "identity", color = "black",
             aes(fill = factor(n_methods))) +
    scale_fill_brewer(direction = 1) +
    guides(fill = FALSE) +
    geom_text(stat = 'identity', aes(label = N),
              size = default.font.size*(5/14),
              hjust = -.05) +
    geom_text(stat = 'identity', aes(label = "", y = N*1.1), hjust = -.05,
              size = default.font.size*(5/14)) +
    scale_y_continuous(expand = c(0, 0)) +
    coord_flip() +
    facet_grid(facets = n_methods ~ ., scales = "free_y", space = "free") +
    geom_text(stat = 'identity', aes(label = "", y = N * 1.1)) +
    xlab("Method combinations") + ylab("CircRNAs") +
    ggtitle(paste("CircRNAs commonly\ndetected by the methods")) +
    theme_bw() +
    theme(text = element_text(size = default.font.size),
          plot.title = element_text(hjust = 0.5))

```


# Detected circRNAs

For each method, at least `r min_reads` reads were required to consider a circRNAs as detected. Further, circRNAs detected by at least `r min_methods` methods are considered as _reliable_.

With at least `r min_reads` reads | With at least `r min_reads` reads and `r min_methods` methods
---------------: | -----------------------------------------:
`r length(detected_circ_ids)` | `r circrnas.morethan2methods.medrpm.table[, .N]`

The reliable circRNAs have been saved in file <a href="`r circRNA_expression_per_sample.csv.basename`">`r circRNA_expression_per_sample.csv.basename`</a>. Expression values represent the median of raw counts predicted by the methods.  

## CircRNAs detected by sample

```{r show_circrnas_2reads_2methods_sample, echo=FALSE, include=TRUE}
circ.2reads.at.least <- 
    circrnas.gtf[circ_id %in% detected_circ_ids, .N, 
                 by = .(sample_id, circ_id)][, .(above_min_reads = .N), 
                                             by = sample_id]
colnames(circ.2reads.at.least)[colnames(circ.2reads.at.least) == "above_min_reads"] <- 
    paste0("\u2265 ", min_reads, " reads")

circrnas.morethan2methods.medrpm <- 
    melt(circrna.rpms[reliable.circrna == 1, c("circ_id", meta$sample_id), with = F], 
         id.vars = "circ_id", 
         variable.name = "sample_id", 
         value.name = "reads")[sample_id != "reliable.circrna"][reads > 0]

coln <- paste0("\u2265 ", min_reads, " reads & \u2265 ", min_methods, " methods")
circ.2reads.at.least.2methods.at.least <- 
    circrnas.morethan2methods.medrpm[, .N, by = .(sample_id, 
                                                  circ_id)][, .(reliable = .N),
                                                            by = sample_id]
colnames(circ.2reads.at.least.2methods.at.least)[colnames(circ.2reads.at.least.2methods.at.least) == "reliable"] <- coln
reliable.circ.tab <- merge(circ.2reads.at.least, circ.2reads.at.least.2methods.at.least, by = "sample_id")

datatable(reliable.circ.tab, 
          rownames = F, 
          style = "bootstrap", class = "compact display", 
          caption = "", 
          fillContainer = F, autoHideNavigation = T, options = list(searching = F))
```

```{r}
reliable.circ.tab.long <- melt(data = reliable.circ.tab, id.vars = "sample_id", 
                               variable.name = "Filter", value.name = "count")
reliable.circ.tab.long.d <- merge(reliable.circ.tab.long, intgroup.dt, 
                                  by = "sample_id")[order(condition, sample_id)]
reliable.circ.tab.long.d$sample_id <- factor(reliable.circ.tab.long.d$sample_id, 
                                             levels =  unique(reliable.circ.tab.long.d$sample_id),
                                             ordered = T)
```

```{r, echo=FALSE, include=TRUE, fig.width=12}
# ggplot(data = reliable.circ.tab.long.d, 
#        mapping = aes(x = sample_id, y = count,
#                      fill = sample_id)) + 
#     geom_bar(stat = "identity", width = .7, aes(colour = sample_id), position = "dodge") + 
#     geom_text(stat ='identity', aes(label = count), 
#               vjust = -0.3, size = default.font.size*(5/14)) +
#     geom_text(stat = 'identity', aes(label = "", y = count*1.1), 
#               vjust = -0.3, size = default.font.size*(5/14))  + 
#     scale_y_continuous(expand = c(0, 0)) + 
#     scale_fill_manual(values = setNames(intgroup.dt[, color], 
#                                         nm = intgroup.dt[, sample_id]), 
#                       guide = F) +
#     scale_color_manual(values = setNames(intgroup.dt[, hue], 
#                                          nm = intgroup.dt[, sample_id]), 
#                        guide = F) +
#     facet_wrap(facets = ~ Filter) + 
#     ggtitle("CircRNAs per sample") + 
#     xlab("") + 
#     ylab("Number of circRNAs") + 
#     theme_bw() + 
#     theme(plot.title = element_text(hjust = 0.5),
#           text = element_text(size=default.font.size), 
#           axis.text.x = element_text(angle=45, hjust=1))

```

```{r, echo=FALSE, include=TRUE, fig.width=12}
reliable.circ.tab.long.d$sample_id <- 
    factor(reliable.circ.tab.long.d$sample_id, 
           levels = reliable.circ.tab.long.d[Filter == paste0("\u2265 ", 
                                                              min_reads, 
                                                              " reads")][order(-count),
                                             sample_id], 
           ordered = T)

ggplot(data = reliable.circ.tab.long.d, 
       mapping = aes(x = sample_id, y = count,
                     fill = Filter)) + 
    geom_bar(stat = "identity", width = .7, 
             # aes(colour = sample_id), 
             position = "dodge") + 
    geom_text(stat ='identity', 
              aes(label = count, y = 0.1), 
              hjust = -.1,
              position = position_dodge(width = .7),
              angle = 90, 
              size = default.font.size*(5/14)) +
    geom_text(stat = 'identity', aes(label = "", y = count*1.1), 
              vjust = -0.3, size = default.font.size*(5/14))  + 
    scale_y_continuous(expand = c(0, 0)) + 
    scale_fill_viridis_d(option = "D", begin = .35, end = .7, alpha = .8, name = NULL) +
    facet_grid(facets = . ~ condition, scales = "free_x", drop = T, space = "free") + 
    # ggtitle("CircRNAs per sample") + 
    xlab("") + 
    ylab("CircRNAs") + 
    theme_bw() + 
    theme(plot.title = element_text(hjust = 0.5), 
          panel.spacing.x = unit(.1, "lines"),
          text = element_text(size=default.font.size), 
          legend.position = "top", 
          axis.text.x = element_text(angle=45, hjust=1))

```


## CircRNAs gene annotation

The following analysis considers the __reliable circRNAs__, which are the `r circrnas.morethan2methods.medrpm.table[, .N]` circRNAs detected with at least `r min_reads` reads and by at least `r min_methods` methods. 

```{r show circrnas categories tab, echo=FALSE, include=TRUE}
circrnas.morethan2methods.medrpm <- 
    merge(circrnas.morethan2methods.medrpm, 
          circ_to_genes[, .(circ_id, sorted_label = simple_gene_region)], 
          by = "circ_id", all.x = T, all.y = F)

circrna.categories.tab <- 
    circrnas.morethan2methods.medrpm[
    , .N, by = .(circ_id, sorted_label)][
        , .N, by = sorted_label][
            order(-N), .(Category = sorted_label, "All samples" = N)]

circrna.categories.tab <- circrnas.morethan2methods.medrpm[
    , .N, by = .(circ_id, sorted_label)][
        , .N, by = sorted_label][
            order(-N), .(Category = sorted_label, "All samples" = N)]

## by sample
if(nrow(circrnas.morethan2methods.medrpm) > 0){
    circrna.categories.tab.ext <- dcast(circrnas.morethan2methods.medrpm[
        , .N, by = .(circ_id, sorted_label, sample_id)][
            , .N, by = .(sorted_label, sample_id)], 
        formula = sorted_label ~ sample_id, value.var = "N", fill = 0)
    
    circrna.categories.tab.ext <- merge(circrna.categories.tab, 
                                        circrna.categories.tab.ext, 
                                        by.x = "Category", by.y = "sorted_label", all = T)
    ## by condition
    circrna.categories.cond.tab <- dcast(merge(circrnas.morethan2methods.medrpm[
        , .N, by = .(circ_id, sorted_label, sample_id)],
        intgroup.dt[, .(condition, sample_id)], by = "sample_id")[
            , .N, by = .(condition, sorted_label)], 
        formula = sorted_label ~ condition, value.var = "N", fill = 0)
    
    circrna.categories.tab.ext <- merge(circrna.categories.tab.ext, circrna.categories.cond.tab,
                                        by.x = "Category", by.y = "sorted_label", all = T)[order(-`All samples`),]
}
```

In the following, circRNA categories are grouped into three main classes: _exonic_, _intronic_, and _intergenic_. A circRNAs is assigned to _exonic_ any of its backsplice ends overlaps an annotated exon; _intronic_ when either both ends overlap introns or one of the two overlaps an intron and the other is in an intergenic region; _intergenic_ when both ends overlap intergenic regions.  

```{r show circrnas classes tab, echo=FALSE, include=TRUE}
circ.cat.cond.xpr <- 
    merge(circrnas.morethan2methods.medrpm[, .(circ_id, reads, sample_id, 
                                               simple_label = sorted_label)], 
          intgroup.dt[, .(condition, sample_id)], by = "sample_id")

## TABLE
## all samples together
circrna.classes.tab <- 
    circ.cat.cond.xpr[, .N, 
                      by = .(circ_id, 
                             simple_label)][, .N, by = simple_label][
                                 order(-N), .(Class = simple_label, 
                                              "All samples" = N)]

## by condition
circrna.classes.cond.tab <- 
    dcast(merge(circ.cat.cond.xpr[, .N, by = .(circ_id, simple_label, sample_id)],
                intgroup.dt[, .(condition, sample_id)], 
                by = "sample_id")[, .N, by = .(condition, simple_label)],
        formula = simple_label ~ condition, value.var = "N", fill = 0)

circrna.categories.tab.ext <- 
    merge(circrna.classes.tab, 
          circrna.classes.cond.tab,
          by.x = "Class", by.y = "simple_label", 
          all = T)[order(-`All samples`)]

## by sample
circrna.classes.tab <- 
    dcast(circ.cat.cond.xpr[, .N, 
                            by = .(circ_id, simple_label, 
                                   sample_id)][, .N, 
                                               by = .(simple_label, 
                                                      sample_id)],
          formula = simple_label ~ sample_id, value.var = "N", fill = 0)

circrna.classes.tab.ext <- merge(circrna.categories.tab.ext,
                                 circrna.classes.tab,
                                 by.x = "Class", by.y = "simple_label", 
                                 all = T)

## TABLE of circRNA category counts
datatable(data = circrna.classes.tab.ext,
          rownames = F,
          style = "bootstrap", class = "compact display",
          caption = "Number of circRNAs according to backsplice overlap with gene annotation (classes)",
          fillContainer = F, autoHideNavigation = T, 
          options = list(searching = F, paging = F, info = F))

```

## CircRNAs expressed per gene

```{r circrnas_per_gene, echo=FALSE, include=TRUE}
## Number of circRNAs per gene
circRNAs.to.gene <- 
    circ_to_gene[gene_region != "intergenic" & 
                     circ_id %in% as.character(circrnas.morethan2methods.medrpm.table$circ_id)]

## count circRNAs per gene and set the list of circRNAs of the gene
n.circ.per.gene <- circRNAs.to.gene[, .(n_circRNAs = .N, 
                                        circ_ids = paste0(unique(circ_id), collapse = "|")), 
                                    by = .(gene_id, gene_name)][order(-n_circRNAs)]

## save number of circRNAs per gene into a file
circRNAs_per_gene.file <- file.path(results.dir, "circRNAs_per_gene.csv")
write.csv(x = n.circ.per.gene, 
          file = circRNAs_per_gene.file, 
          row.names = F)

circRNAs.per.gene <- circRNAs.to.gene[, .(circRNAs_per_gene = .N),
                                      by = gene_id][order(-circRNAs_per_gene)]

```

`r n.circ.per.gene[, .N]` genes overlap `r circrnas.morethan2methods.medrpm.table[gene_region != "intergenic", .N]` reliable circRNAs.   
`r circrnas.morethan2methods.medrpm.table[gene_region == "intergenic", .N]` _intergenic_ circRNAs were clustered into `r circrnas.morethan2methods.medrpm.table[gene_region == "intergenic", .N, by = gene_names][, .N]` putative new genes.  

Number of circRNAs expressed by each gene ( _intergenic_ circRNAs excluded) are reported in file <a href="`r basename(circRNAs_per_gene.file)`">`r basename(circRNAs_per_gene.file)`</a>.  

### Overall circRNAs per gene  

```{r plot_circrnas_per_gene, echo=FALSE, include=TRUE, fig.width=12}
## barplot
ggplot(data = circRNAs.per.gene, 
       mapping = aes(x = factor(circRNAs_per_gene))) + 
    geom_bar(stat = "count") +
    # geom_text(stat = "count", aes(label = ..count..),
    #           vjust = -0.3, size = default.font.size*(5/14)) +
    geom_text(stat = "count", aes(label = "", y = ..count..*1.1), vjust = -0.3,
              size = default.font.size*(5/14)) +
    scale_y_continuous(expand = c(0, 0)) + 
    ggtitle("CircRNAs per gene") + 
    xlab("Number of circRNAs") + 
    ylab("Number of genes") + 
    theme_bw() + 
    theme(text = element_text(size=default.font.size), 
          axis.text.x = element_text(angle = 90, hjust = 1),
          plot.title = element_text(hjust = 0.5))
```

### Per sample circRNAs per gene

```{r echo=FALSE, include=TRUE}
## Number of circRNA per gene, discriminating each sample
circRNAs.to.gene.per.sample <- 
    merge(circrnas.morethan2methods.medrpm[sorted_label != "intergenic", 
                                           .(circ_id, sample_id)], 
          circRNAs.to.gene[, .(circ_id, gene_id, gene_name, simple_gene_region)], 
          by = "circ_id", 
          all.x = T, 
          all.y = F, 
          allow.cartesian = T)

n.circ.per.gene.per.sample <- 
    circRNAs.to.gene.per.sample[simple_gene_region != "intergenic", 
                                .(n_circRNAs = .N, 
                                  circ_ids = paste0(unique(circ_id), 
                                                    collapse = "|")), 
                                by = .(sample_id, gene_id, 
                                       gene_name)][order(sample_id, -n_circRNAs)]

## save circRNAs per gene per sample
circRNAs_per_gene.per.sample.file <- 
    file.path(results.dir, "circRNAs_per_gene_per_sample.csv")
write.csv(x = n.circ.per.gene.per.sample,
          file = circRNAs_per_gene.per.sample.file,
          row.names = F)

circRNAs.per.gene.per.sample <- 
    n.circ.per.gene.per.sample[, .(gene_id, gene_name, 
                                   circRNAs_per_gene = n_circRNAs, 
                                   sample_id)]
```

```{r}
fig.height <- max(ceiling(meta[, .N]/2), 2)*2
```

```{r, echo=FALSE, include=TRUE, fig.width=12, fig.height=fig.height}
circRNAs.per.gene.per.sample$sample_id <- 
    factor(circRNAs.per.gene.per.sample$sample_id, 
           levels = meta[order(condition, sample_id), sample_id], 
           ordered = T)

## barplot
ggplot(data = circRNAs.per.gene.per.sample, 
       mapping = aes(x = factor(circRNAs_per_gene),
                     fill = sample_id, 
                     color = sample_id)) + 
    geom_bar(stat = "count") + 
    facet_wrap(facets = ~ sample_id, scales = "free", 
               ncol = min(2, meta[, .N])) + 
    scale_fill_manual(values = setNames(intgroup.dt[, color], nm = intgroup.dt[, sample_id])) +
    scale_color_manual(values = setNames(intgroup.dt[, hue], nm = intgroup.dt[, sample_id])) + 
    geom_text(stat = "count", aes(label = "", y = ..count..*1.1)) +
    scale_y_continuous(breaks = function(x) unique(floor(pretty(seq(0, (max(x) + 1) * 1.1)))),
                       expand = c(0, 0)) +
    ggtitle("CircRNAs per gene") + 
    xlab("Number of circRNAs") + 
    ylab("Number of genes") + 
    theme_bw() + 
    theme(text = element_text(size = default.font.size), 
          axis.text.x = element_text(angle = 90, hjust = 1),
          plot.title = element_text(hjust = 0.5)) + 
    guides(fill = FALSE, color = FALSE)
```

Number of circRNAs expressed per gene, per each sample, have been saved in file <a href="`r basename(circRNAs_per_gene.per.sample.file)`">`r basename(circRNAs_per_gene.per.sample.file)`</a>. 

### Per condition number of circRNAs per gene

```{r}
fig.height <- max(length(unique(meta$condition))*3, 2)
```

```{r}
circRNAs_per_gene.per.cond.file <- "Not applicable to this settings"
circRNAs.to.gene.per.sample <- merge(circRNAs.to.gene.per.sample, 
                                     intgroup.dt[, .(sample_id, condition)], 
                                     by = "sample_id")

if(intgroup.dt[, .N, by=condition][, .N] > 1){
    
    n.circ.per.gene.per.condition <- 
        unique(circRNAs.to.gene.per.sample[, .(circ_id, gene_id, gene_name, 
                                               condition)])[, .(n_circRNAs = .N,
                                                                circ_ids = paste0(unique(circ_id), 
                                                                                  collapse = "|")), 
                                                            by = .(condition, gene_id,
                                                                   gene_name)][order(condition,
                                                                                     -n_circRNAs)]
    
    circRNAs.per.gene.per.condition <- 
        n.circ.per.gene.per.condition[, .(gene_id, gene_name, 
                                          circRNAs_per_gene = n_circRNAs,
                                          condition)]
    
    circRNAs_per_gene.per.cond.file <- file.path(results.dir, "circRNAs_per_gene_per_condition.csv")
    write.csv(x = n.circ.per.gene.per.condition,
              file = circRNAs_per_gene.per.cond.file,
              row.names = F)
}
```

```{r plot_circrnas_per_gene_per_condition, echo=FALSE, include=TRUE, fig.width=12, fig.height=fig.height}
if(intgroup.dt[, .N, by=condition][, .N] > 1){
    ## barplot per condition
    ggplot(data = circRNAs.per.gene.per.condition, 
           mapping = aes(x = factor(circRNAs_per_gene), 
                         fill = condition)) + 
        geom_bar(stat = "count") + 
        facet_wrap(facets = ~ condition, scales = "free", 
                   nrow = intgroup.dt[, .N, by = condition][, .N]) + 
        geom_text(stat = "count", aes(label = "", y = ..count..*1.1)) +
        scale_y_continuous(breaks = function(x) unique(floor(pretty(seq(0, (max(x) + 1) * 1.1)))),
                           expand = c(0, 0)) +
        ggtitle("CircRNAs per gene") + 
        xlab("CircRNA isoforms per gene") + 
        ylab("Genes") + 
        theme_bw() + 
        scale_fill_manual(values = setNames(unique(intgroup.dt[, hue]), 
                                            nm = unique(intgroup.dt[, condition])),
                          guide = FALSE) + 
        theme(text = element_text(size=default.font.size), 
              axis.text.x = element_text(angle = 90, hjust = 1),
              plot.title = element_text(hjust = 0.5))
}
```

Number of circRNAs expressed per gene, grouping by condition, have been saved in file <a href="`r basename(circRNAs_per_gene.per.cond.file)`">`r basename(circRNAs_per_gene.per.cond.file)`</a>. 

# Circular to linear expression ratio (CLR)

```{r}
bks_linear_counts.tab.gz.m <- 
    fread(bks_linear_counts.tab.gz.file, 
          showProgress = F)[circ_id %in%
                                as.character(circrnas.morethan2methods.medrpm.table$circ_id)]

bks_linear_counts.tab.gz <- 
    dcast(bks_linear_counts.tab.gz.m,
          formula = circ_id ~ sample_id,
          value.var = "lin.reads")
```

```{r}
## save linear expression relative to circRNAs
circrna.lin.xpr.filename <- "reliable.circrna.lin.xpr.csv"
write.csv(x = bks_linear_counts.tab.gz, 
          file = file.path(results.dir, circrna.lin.xpr.filename), 
          row.names = F)
```

Linear expression of reliable circRNAs have been saved in file <a href="`r circrna.lin.xpr.filename`">`r circrna.lin.xpr.filename`</a>  


```{r}
circ.lin.xpr <- 
    merge(circrnas.morethan2methods.medrpm,
          bks_linear_counts.tab.gz.m, 
          by = c("sample_id", "circ_id"),
          all.x = T, all.y = F)[, .(sample_id, circ_id, 
                                    CLR = (2*reads)/lin.reads)]


```

```{r}
## save CLR 
circ.lin.xpr.filename <- "reliable.circrna.clr.csv"
write.csv(x = circ.lin.xpr, 
          file = file.path(results.dir, circ.lin.xpr.filename), 
          row.names = F)
```

Circular to linear expression ratios have been saved in file <a href="`r circ.lin.xpr.filename`">`r circ.lin.xpr.filename`</a>  

```{r}
circ.lin.xpr <- merge(circ.lin.xpr, 
                      meta, by = "sample_id")
```

```{r, fig.width=2}
ggplot(circ.lin.xpr, aes(x = "", y = log2(CLR))) +
    geom_boxplot() +
    xlab(NULL) +
    ylab(expression(Log[2](CLR))) +
    theme_bw() +
    theme(axis.ticks.x = element_blank(), axis.text.x = element_blank())
```

```{r}
ggplot(circ.lin.xpr, 
       aes(x = condition, y = log2(CLR), fill = condition)) +
    geom_boxplot(varwidth = T) +
    xlab(NULL) +
    ylab(expression(Log[2](CLR))) +
    scale_fill_manual(values = setNames(unique(intgroup.dt[, hue]), 
                                        nm = unique(intgroup.dt[, condition])), 
                      guide = F) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
ggplot(circ.lin.xpr, aes(x = sample_id, y = log2(CLR), fill = sample_id)) +
    geom_boxplot(varwidth = T) +
    facet_wrap(facets = ~ condition, drop = T, scales = "free_x", 
               ncol = min(3, length(unique(meta$condition)))) +
    xlab(NULL) +
    ylab(expression(Log[2](CLR))) +
    scale_fill_manual(values = setNames(intgroup.dt[, color], 
                                        nm = intgroup.dt[, sample_id]), 
                      guide = F) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

# Session info

This page was generated with the following packages version

```{r session, echo=FALSE}
sessionInfo()
```
