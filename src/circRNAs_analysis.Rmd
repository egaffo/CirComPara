---
title: "CirComPara: detection and analysis of circular RNAs"
date: "`r Sys.Date()`"  
output: 
  html_document: 
    keep_md: no
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: 
      collapsed: false
      smooth_scroll: true
    theme: "readable"
---

# CirComPara results summary

CirComPara analysis results are presented in this page. Different sections display aggregated data in tables and figures. Raw and integrated results were saved in comma separated (CSV) files. 

```{r global_options, include=FALSE}
## variables to be defined in parent frame
# results.dir
# circrnas.gtf.file
# combined_gtf_file# 
# min_methods ## minimum number of methods detecting a circRNA to define it "reliable"
# min_reads
# meta_file
# bks_linear_counts.tab.gz.file

dir.create(path = results.dir, showWarnings = F, recursive = T)
knitr::opts_chunk$set(fig.width = 6, 
                      fig.height = 4, 
                      dev = c('svglite', 'png'), 
                      fig.pos = "center",
                      fig.path = file.path(results.dir, paste0('Figs', .Platform$file.sep)),
                      echo = FALSE, 
                      warning = FALSE, 
                      message = FALSE)
library(knitr)
library(data.table)
library(ggplot2)
library(RColorBrewer)
library(scales)
library(DT)
```


```{r utility_functions, echo=FALSE, include=FALSE}
# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)
  
  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)
  
  numPlots = length(plots)
  
  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }
  
  if (numPlots==1) {
    print(plots[[1]])
    
  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    
    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
      
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

# Compute label for a circRNA according to gene overlaps
#
# This function serves to categorize backsplices according to the positions
# relative to gene/exons.
# An "error region" of the exon/backsplice coordinates could be considered
# by setting flank > 0
# We define three backsplice categories:
# 1. Intergenic: both start and end are outside any gene
# 2. Intronic: both end are in intron(s)
# 3. Exonic: either start or end is in exon(s)
#
# - backsplice: a two elements integer array with start and end of the circRNA
# - exon:       a two elements integer array with start and end of the exon
# - gene:       a two elements integer array with start and end of the gene
# - flank:      the number of flanking bases allowed for the backspice coordinates
#
label.backsplice <- function(backsplice, exon, gene, flank = 0){
  
  gene_start <- gene[1] - flank
  gene_end <- gene[2] + flank
  exon_start <- exon[1] - flank
  exon_end <- exon[2] + flank
  circ_start <- backsplice[1]
  circ_end <- backsplice[2]
  
  category <- "undefined"
  if(exon_start < 0){
    category <- "intergenic"
  }else{
    if(circ_start >= gene_start | circ_end <= gene_end){ # are we inside a gene?
      category <- "intronic"
      if(circ_start >= exon_start | circ_end <= exon_end){ # are we within an exon?
        category <- "exonic"
      }
    }else{
      # we are not inside a gene, but an exon is overlapped
      if(circ_start < gene_start & circ_end > gene_end){ # just double check we are completely outside a gene
        category <- "intergenic_spanning_gene"
      }
    }
  }
  category
}

# Refine labelling for a circRNA
#
# - labels_list: the list of labels assigned to i circRNA ID
#
refine_label <- function(labels_list){
  
  if("exonic" %in% labels_list){
    label <- "exonic"
  }else{
    if("intronic" %in% labels_list){
      label <- "intronic"
    }else{
      if("intergenic" %in% labels_list){
        label <- "intergenic"
      }else{
        label <- paste0(sort(unique(labels_list)), collapse = ",")
      }
    }
  }
  label
}

# reduce complexity of labels. Simplify into exonic, intronic, intergenic 
# categories. The function simply assign "exonic" if at least one exon 
# overlaps the backsplice; otherwise, "intron" if an intron overlaps; 
# otherwise, "intergenic" for either intergenic and intergenic_spanning_gene;
# "other" as a backfall label that should not appear.
# - label: the collapsed labels for a circRNA
simplify_circrna_labels <- function(label){
    lab <- "other"
    if(grepl("exon", label)){
        lab <- "exonic"
    }else{
        if(grepl("intergenic", label)){
            lab <- "intergenic"
        }
        if(grepl("intron", label)){
            lab <- "intronic"
        }
    }
    lab
}
```

```{r set custom color shades}
## set custom color shades
## function to compute color hues and colors to give to each sample
get.color.hues <- function(meta){
    intgroup.dt <- meta[, .(.N), by = .(sample_id, 
                                        condition)][order(sample_id), 
                                                    .(sample_id), by = condition]
    samples.per.condition <- data.frame(intgroup.dt[, .N, by = .(condition)], 
                                        row.names = "condition")
    n.conditions <- nrow(samples.per.condition)
    hues <- brewer_pal(palette = "Set2")(n.conditions)
    
    if(nrow(intgroup.dt) == 1){
        intgroup.dt[, `:=`(color = hues[1],  hue = hues[1])]
    }else{
        for(i in 1:n.conditions){
            n.hues <- samples.per.condition[i, "N"] + 2
            col.hues <- colorRampPalette(colors = c(hues[i], 
                                                    "white"))(n.hues)[1:(n.hues-2)]
            
            intgroup.dt[condition == rownames(samples.per.condition)[i], `:=`(color = col.hues,
                                                                              hue = hues[i])]
        }
    }
    intgroup.dt[]
}
```

```{r, echo=FALSE}
if(meta_file != ""){
    meta <- unique(fread(meta_file)[, .(sample_id = sample, condition)])
    intgroup.dt <- get.color.hues(meta)
}
```

```{r load_circrnas, echo=FALSE, include=FALSE}
## read circRNA results: filter low expressed (less than min_reads reads) circRNAs
colClasses <- c("factor", "factor", "character", "integer", 
                "integer", "integer", "factor", "character", "character")
circrnas.gtf <- fread(circrnas.gtf.file, data.table = T, 
                      colClasses = colClasses)
V9pattern <- '.*gene_id "([^"]*)".*transcript_id "([^"]*)".*'
V9newCols <- c("gene_id", "transcript_id")
exists_circrnas <- FALSE
if(nrow(circrnas.gtf[V6 >= min_reads]) > 0){
  exists_circrnas <- TRUE
  circrnas.gtf[, `:=` (sample_id = sub('.*sample_id "([^"]*)".*', "\\1", V9))
               ][, (V9newCols) := tstrsplit(sub(V9pattern, 
                                                "\\1@\\2", V9), "@", fixed=TRUE)
                 ][, V9 := NULL]
  full.circrnas.gtf <- copy(circrnas.gtf)
  circrnas.gtf <- circrnas.gtf[V6 >= min_reads]
  ## normalize circrna reads by the amount of backsplice Reads in method (Per Million reads - RPM)
  # circrnas.gtf[, RPM := (V6/sum(V6))*10^6, by = .(sample_id, V2)]
  ## use DESeq normalization to compute RPMs
  suppressPackageStartupMessages(library(DESeq2))
  full.circrnas.gtf.mat.dt <- 
      dcast(full.circrnas.gtf, formula = gene_id ~ sample_id + V2, 
            value.var = "V6", fill = 0, sep = ".._..", fun.aggregate = sum)
  full.circrnas.gtf.mat <- as.matrix(full.circrnas.gtf.mat.dt, 
                                     rownames = "gene_id")
  
  full.meta <- 
      data.frame(unique(full.circrnas.gtf[, .(sample_id, 
                                              method = V2, 
                                              id = paste(sample_id, V2, 
                                                         sep = ".._.."))]),
                 row.names = "id")
  dds <- 
      DESeqDataSetFromMatrix(full.circrnas.gtf.mat[, rownames(full.meta)], 
                             colData = full.meta,
                             design = ~1)
  dds <- estimateSizeFactors(dds, type = "poscount")
  
  norm.counts <- counts(dds, normalized = T)
  norm.counts.m <- as.data.table(melt(norm.counts, 
                                      varnames = c("gene_id", "id"),
                                      value.name = "RPM"))
  norm.counts.m <- merge(norm.counts.m, 
                         data.table(full.meta, keep.rownames = "id"), 
                         by = "id")
  
  circrnas.gtf <- 
      merge(circrnas.gtf, 
            norm.counts.m[, .(gene_id, RPM, sample_id, V2 = method)], 
            by = c("gene_id", "V2", "sample_id"), 
            all.x = T, all.y = F)
  
  ## compute median of normalized value
  circrna.rpms <- 
      data.table::dcast(data = circrnas.gtf, 
                        formula = sample_id + gene_id + V1 + V4 + V5 + V7 ~ V2, 
                        value.var = "RPM", fill = 0)
  ## account also 0s for the computation of the meadian RPM
  #circrna.rpms$medRPM <- apply(X = circrna.rpms[, 7:ncol(circrna.rpms), with = F], MARGIN = 1, FUN = median)
  ## remove 0s from computation of the meadian RPM
  circrna.rpms <- merge(circrna.rpms, 
                        circrnas.gtf[, .(medRPM = median(RPM)), 
                                     by = .(sample_id, gene_id)], 
                        by = c("sample_id", "gene_id"))
}else{
  circrnas.gtf[, `:=`(RPM="", gene_id="")]
  circrna.rpms <- circrnas.gtf
  circrna.rpms.genes <- circrna.rpms
  circrna.rpms.genes[, `:=`(circ_id="", gene_ids="", gene_names="", label="", sample_id="", chr="", V1="", start="", V4="", 
                            end="", V5="", strand="", V7="", medRPM="")]
}

```

```{r load_circrna_gene_overlaps, echo=FALSE, include=FALSE}
## retrieve and attach gene symbols and gene_ids: use only exons hit by the backsplice coordinates 
# colClasses <- c("factor", "factor", "character", "integer", "integer", "integer", "factor", "character", "character",
#                 "factor", "factor", "character", "integer", "integer", "character", "factor", "character", "character")
# colClasses <- list(factor = c(1, 4, 6, 7, 10), 
#                    integer = c(2L, 3L, 8L, 9L), 
#                    character = c(5, 11))
#colToDrop <- c("V3", "V8", "V11", "V12", "V15", "V17")
#combined_gtf <- fread(paste0('zcat ', combined_gtf_file), data.table = T, colClasses = colClasses, drop = colToDrop)
combined_gtf <- fread(cmd = paste0('zcat ', combined_gtf_file), data.table = T, 
                      # colClasses = colClasses, 
                      drop = c(2,3,
                               4,5,
                               6,8,11,15,17))
exists_gene_overlaps <- FALSE
if(nrow(combined_gtf) > 0){
  exists_gene_overlaps <- TRUE
  # if(fix_testrealign){
  #   setkey(combined_gtf, V2)
  #   combined_gtf["testrealign", V4 := V4-1]
  # }
  combined_gtf[, `:=`(circ_id = sub('.*gene_id "([^"]*)".*', '\\1', V9),
                      gene_id = sub('.*gene_id "([^"]*)".*', "\\1", V18), 
                      gene_name = ifelse(grepl('gene_name', V18, fixed = T), 
                                         sub('.*gene_name "([^"]*)".*', "\\1", 
                                             V18), "."),
                      # sample_id = sub('.*sample_id "([^"]*)".*', "\\1", V9),
                      chr = V1, 
                      # circ_start = as.integer(V4), 
                      # circ_end = as.integer(V5), 
                      strand = V7,
                      gene_chr = V10, 
                      exon_start = as.integer(V13), 
                      exon_end = as.integer(V14), 
                      exon_strand = V16)
               ][, `:=`(V1 = NULL, 
                        # V4 = NULL, V5 = NULL, 
                        V7 = NULL, V9 = NULL, 
                        V10 = NULL, V13 = NULL, V14 = NULL, V16 = NULL, V18 = NULL)]
  # combined_gtf[, `:=`(gene_start = min(exon_start), 
  #                     gene_end = max(exon_end)), 
  #              by = gene_id]
  combined_gtf[V12 == ".", V12 := "intergenic"]
  
  # circ_to_gene <- combined_gtf[, .(counts = .N), by = .(chr, circ_start, circ_end, strand, 
  #                                                       exon_start, exon_end, gene_id, gene_name, 
  #                                                       gene_start, gene_end)][, counts := NULL]
  # 
  # 
  # 
  # circ_to_gene[, rowId := .I]
  # circ_to_gene[, label := label.backsplice(c(circ_start, circ_end), 
  #                                          c(exon_start, exon_end), 
  #                                          c(gene_start, gene_end), 
  #                                          flank = 1),
  #              by = rowId]
  # circ_to_gene[, `:=` (rowId = NULL)]
  # 
  # ## keep order of labels the same of the order of genes
  # circ_to_genes <- circ_to_gene[, .(circ_id = paste0(chr, ":", circ_start, "-", circ_end, ":", strand), 
  #                                   gene_id, gene_name, label)][
  #                                     , .(label = refine_label(label)), by = .(circ_id, gene_id, gene_name)][
  #                                       , .(gene_ids = paste0(unique(gene_id), collapse = "|"),
  #                                           gene_names = paste0(unique(gene_name), collapse = "|"),
  #                                           label = paste0(unique(label), collapse = "|")), 
  #                                       by = circ_id]
  
  circ_to_gene <- combined_gtf[, .(features = paste(sort(unique(V12)), collapse = ",")),
                                by = .(circ_id, gene_id, gene_name)]
  circ_to_genes <- circ_to_gene[, .(label = paste0(sort(unique(features)), collapse = "|"),
                                    gene_ids = paste0(gene_id, collapse = "|"),
                                    gene_names = paste0(gene_name, collapse = "|")), 
                                by = .(circ_id)]
}

if(exists_circrnas & exists_gene_overlaps){
  setkey(circrna.rpms, gene_id)
  setkey(circ_to_genes, circ_id)
  circrna.rpms.genes <- circ_to_genes[circrna.rpms]
  
  ## split results per sample
  ## NB: use split function from data.table >= 1.9.7
  circrnas_expression.samples <- split(circrna.rpms.genes, by = "sample_id", keep.by = F, drop = T)
  
  ## save tables: one per sample
  save.sample.table <- function(sample, outdir){
    table.file <- file.path(outdir, paste0(sample, "_circrna_norm_expression.csv"))
    write.csv(x = circrnas_expression.samples[[sample]], file = table.file, row.names = F)
    table.file
  }
  
  sample.table.file.names <- sapply(X = names(circrnas_expression.samples), 
                                    FUN = save.sample.table, 
                                    outdir = results.dir)
}else{
  sample.table.file.names <- "No circRNAs detected"
}
```

Backsplices were detected using `r circrnas.gtf[, .N, by = V2][, .N]` programs in parallel: `r paste0(sort(circrnas.gtf[, .N, by = V2][, V2]), collapse = ", ")`

The detected circRNAs were saved in the following files:
```{r sample_circrna_table_files, echo=FALSE, include=TRUE}
sample.table.file.names <- as.data.frame(sample.table.file.names, stringsAsFactors = F)
sample.table.file.names$Sample <- rownames(sample.table.file.names)
sample.table.file.names <- sample.table.file.names[sort(rownames(sample.table.file.names)), ]
sample.table.file.names$basenames <-  sapply(sample.table.file.names$sample.table.file.names, 
                                                            basename)
sample.table.file.names$File <- sapply(sample.table.file.names$basenames, 
                                                            sub, pattern = "(.*)", 
                                                            replacement = '<a href="\\1">\\1</a>')

#kable(data.table(sample_id = names(sample.table.file.names), file = sample.table.file.names)[order(sample_id)])
kable(sample.table.file.names[, c("Sample", "File")], row.names = F, 
      caption = "Files in which the detected circRNAs were saved. One file per sample.")
```

```{r reliable_circrnas, echo=FALSE, include=TRUE}
############# CircRNA expression per sample ###########
## get the list of circRNAs detected by min_methods or more methods
circrnas.morethan2methods <- circrnas.gtf[, .N, 
                                          by = .(gene_id, V2)][
                                            , N := NULL][
                                              , .(n_methods = .N), 
                                              by = gene_id][
                                                n_methods >= min_methods, .(gene_id)]

## subset the circRNA expression table by the circRNAs detected by at least min_methods methods and
## with normalized median expression > 0
setkey(circrna.rpms.genes, circ_id)
setkey(circrnas.morethan2methods, gene_id)
circrnas.morethan2methods.medrpm <- circrna.rpms.genes[circrnas.morethan2methods][
  , .(circ_id, gene_ids, gene_names, label, sample_id, chr = V1, start = V4, end = V5, strand = V7, medRPM)][medRPM > 0]

circrnas.morethan2methods.medrpm.table <- circrnas.morethan2methods
if(nrow(circrnas.morethan2methods) > 0 ){
  ## reshape with one expression column per sample 
  circrnas.morethan2methods.medrpm.table <- data.table::dcast(data = circrnas.morethan2methods.medrpm, 
                                                              formula = circ_id + gene_ids + gene_names + label + chr + start + end + strand ~ sample_id,
                                                              value.var = "medRPM", fill = 0)
  
  # ## add a useful mean expression column
  # circrnas.morethan2methods.medrpm.table$avg_xpr <- apply(X = circrnas.morethan2methods.medrpm.table[
  #   , 9:ncol(circrnas.morethan2methods.medrpm.table)], 
  #   MARGIN = 1, FUN = mean)
}
## save table
circRNA_expression_per_sample.csv.basename <- "circRNA_expression_per_sample.csv"
write.csv(x = circrnas.morethan2methods.medrpm.table, 
          file = file.path(results.dir, circRNA_expression_per_sample.csv.basename), 
          row.names = F)

## the reference to the file is reported in the document section below

## TODO: save in HTML table with links
```

# Detected circRNA results
## CircRNAs detected per method

```{r show_circrnas_per_method, echo=FALSE, include=TRUE}

circ.per.method <- circrnas.gtf[V6 >= min_reads][, .N, by = .(gene_id, V2)]
#circ.per.method[, .N, by = V2][, Method := V2][order(-N), .(Method, N)]
non.redundant <- circ.per.method[, .N, by = gene_id][, .N]
## number of circRNAs per method
kable(rbind(circ.per.method[, .N, by = V2][, Method := V2][order(-N), .(Method, "Tot circRNAs" = N)], 
            list("Non-redundant", non.redundant)))

############# Barplot number of circRNAs per methods (sum over all samples) ###########
default.font.size <- 12

lev.order <- circ.per.method[, .N, by = V2][order(N), as.character(V2)]
circ.per.method$V2 <- factor(circ.per.method$V2, 
                                 levels = lev.order, ordered = T)

## select only circRNAs with >= 2 reads (not normalized values)
circByMethod.barplot <- 
    ggplot(data = circ.per.method, mapping = aes(x = V2, fill = V2)) + 
    geom_bar(width = .7, colour="black") + 
    geom_text(stat='count', aes(label=..count..), vjust=-0.3,
              size=default.font.size*(5/14)) + 
    theme_bw() + xlab("CircRNA detection method") + 
    ylab("CircRNA number") +
    ggtitle(bquote("CircRNAs detected with " >= .(min_reads) ~ "reads by each method"))

## compute limits to remove space from x-axis. Add a 10% increase to the top limit
circByMethod.barplot.limits <- c(0, max(circ.per.method[, .N, by = V2][, N])*1.1)
circByMethod.barplot + guides(fill=FALSE) + 
    theme(text = element_text(size=default.font.size), 
          plot.title = element_text(hjust = 0.5)) + 
    scale_y_continuous(expand = c(0, 0), limits = circByMethod.barplot.limits) + 
    # scale_fill_manual(values = rainbow(circ.per.method[, .N, by = V2][, .N])) +
    scale_fill_brewer(palette = "Spectral") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

### CircRNAs shared by methods

```{r show_circrnas_shared, echo=FALSE, include=TRUE}

############# Matrix of methods' shared circRNA counts ###########

shared.counts.table <- crossprod(x = table(circ.per.method[
  , `:=`(N = NULL, method = V2, V2 = NULL)]))
## save table
write.csv(x = data.frame(shared.counts.table), 
          file = file.path(results.dir, "methods_shared_circRNA_counts.csv"), 
          row.names = F)

kable(data.frame(shared.counts.table), caption = "")

############# Barplot number of circRNAs shared by methods ###########
## "\u2265" is the unicode character for 'greater than or equal'
sharedByMethod.barplot <- ggplot(data = circ.per.method[, .(shared_by = .N), by = gene_id], 
                                 mapping = aes(x = factor(shared_by), fill = factor(shared_by))) + 
  geom_bar(width = .7, color = "black") + 
  geom_text(stat='count', aes(label=..count..), vjust=-0.3, size=default.font.size*(5/14)) + 
  theme_bw() + xlab("Number of methods") + ylab("CircRNA number") +
  ggtitle(paste("Number of circRNAs (with \u2265", min_reads, "reads)\ncommonly detected by the methods"))
## compute limits to remove space from x-axis. Add a 10% increase to the top limit
sharedByMethod.barplot.limits <- c(0, max(circ.per.method[, .(shared_by = .N), by = gene_id][, .N, by=shared_by][, N])*1.1)
sharedByMethod.barplot + guides(fill=FALSE) + 
  theme(text = element_text(size=default.font.size), plot.title = element_text(hjust = 0.5)) + 
  scale_y_continuous(expand = c(0, 0), limits = sharedByMethod.barplot.limits) + 
  scale_fill_brewer(direction = 1)

```

```{r, fig.width=4}
ggplot(data = circ.per.method[, .(shared_by = .N), 
                              by = gene_id][, .N, by = shared_by], 
       mapping = aes(x = "", y = N,
                     fill = factor(shared_by))) + 
    geom_bar(stat = "identity", width = .7, 
             color = "black", position = position_stack(reverse = T)) + 
    geom_text(stat='identity', aes(label=percent(N/sum(N))),
              position = position_stack(vjust = .5, reverse = T)) +
    scale_fill_brewer("# methods", direction = 1, palette = "Greens") +
    scale_y_continuous(expand = c(0, 0)) +
    scale_x_discrete(expand = c(0, 0)) +
    ylab("CircRNAs") +
    xlab(NULL) +
    # coord_polar(theta = "y") +
    theme_bw() +
    theme(axis.ticks.x = element_blank())
```


```{r}
## save methods detecting each circRNA
cmet_per_circ.file <- file.path(results.dir, "cmet_per_circ.csv")

circ_met <- circrnas.gtf[V6 >= min_reads, 
             .(c_methods = paste0(sort(unique(V2)), collapse = "|"), 
               n_methods = length(unique(V2))),  
             by = .(sample_id, gene_id)] #[n_methods >= min_methods]

write.csv(circ_met[order(sample_id)], cmet_per_circ.file, row.names = F)
```

Methods detecting each circRNAs are listed in  <a href="`r basename(cmet_per_circ.file)`">`r basename(cmet_per_circ.file)`</a>.

```{r}
## cumulative number of circrnas by number of methods
cum.met <- 
    circ.per.method[, .(n_methods = .N), 
                    by = gene_id][, .N, 
                                  by = n_methods][order(-n_methods)][
                                      , .(n_methods, cum.sum = cumsum(N))]

ggplot(cum.met, aes(x = factor(paste0("\u2265", n_methods)), 
                    y = cum.sum, fill = factor(paste0("\u2265", n_methods)))) + 
    geom_col(color = "black") +
    geom_text(aes(label = cum.sum), vjust = -.5) +
    geom_text(label = "", aes(y = cum.sum*1.1)) +
    scale_y_continuous(expand = c(0, 0)) +
    scale_fill_brewer(guide = F, palette = "Reds") +
    xlab("Cumulative number of methods") +
    ylab("CircRNAs") +
    theme_bw()
    
```


```{r}
reduce.cmeth.names <- function(x){
    x <- gsub("circexplorer2", "ce2", x)
    x <- gsub("segemehl", "se", x)
    x <- gsub("tophat", "th", x)
    x
}

circ_met.to.plot <- circrnas.gtf[V6 >= min_reads, 
                                 .N, 
                                 by = .(gene_id, 
                                        V2)][, .(c_methods = paste0(sort(unique(reduce.cmeth.names(V2))), 
                                                                                    collapse = "|"), 
                                                                 n_methods = length(unique(V2))), by = gene_id]
circ_met.plot.height <- max(c(4, (circ_met.to.plot[, .N, by = c_methods][, .N]*0.5)/2.54))

circ_met.to.plot <- 
    circ_met.to.plot[, .N, 
                     by = .(c_methods, 
                            n_methods)][order(-N)]

circ_met.to.plot$c_methods <- 
    factor(circ_met.to.plot$c_methods, 
           levels = circ_met.to.plot$c_methods, 
           ordered = T)
```

```{r, fig.height=`circ_met.plot.height`}
ggplot(circ_met.to.plot, aes(x = c_methods, y = N)) + 
    geom_bar(stat = "identity", color = "black", 
             aes(fill = factor(n_methods))) + 
    scale_fill_brewer(direction = 1) + 
    guides(fill=FALSE) + 
    geom_text(stat = 'identity', aes(label = N), hjust = -.05,
              size = default.font.size*(5/14)) + 
    scale_y_continuous(expand = c(0, 0)) + 
    coord_flip() + 
    facet_grid(facets = n_methods ~ ., scales = "free_y", space = "free") +
    geom_text(stat = 'identity', aes(label = "", y = N * 1.1)) + 
    xlab("Method combinations") + ylab("CircRNAs") +
    ggtitle(paste("CircRNAs commonly\ndetected by the methods")) +
    theme_bw() + 
    theme(text = element_text(size = default.font.size), 
          plot.title = element_text(hjust = 0.5))

```


## CircRNAs detected in total

For each method, at least `r min_reads` reads were required to consider a circRNAs as detected. Further, circRNAs detected by at least `r min_methods` methods are considered more reliable.

With at least `r min_reads` reads | With at least `r min_reads` reads and `r min_methods` methods
---------------: | -----------------------------------------:
`r circrnas.gtf[RPM > 0, .N, by = .(gene_id)][, .N]` | `r circrnas.morethan2methods.medrpm.table[, .N]`

The reliable circRNAs have been saved in file <a href="`r circRNA_expression_per_sample.csv.basename`">`r circRNA_expression_per_sample.csv.basename`</a>. The fields of the table header are explained below:

|Field     |Description                                                                        |
|----------|---------------------------------------------------------------------------------- |
|circ_id   |the circRNA ID, composed as chromosome:start-end:strand (+/-)                      |
|gene_ids  |the circRNA-overlapping gene IDs, separated by a \| character                      |
|gene_names|the circRNA-overlapping gene symbols, separated by a \| character                  |
|label     |circRNA caracterization according to gene annotation, separated by a \| character *|
|chr       |circRNA chromosome                                                                 |
|start     |circRNA (backsplice) start position                                                |
|end       |circRNA (backsplice) end position                                                  |
|strand    |circRNA (backsplice) strand                                                        |
|sample_id |circRNA expression in the sample **                                                | 

\*  The order of the labels correnspond to the order of the overlapping genes. Labels are not repeated thogh, and the number of different label may be lower than the number of different genes.  
\*\* CircRNA expression is reported in reads per million mapped (RPM) computed as the median RPM of the circRNA detection methods used.  

## CircRNAs detected by sample

```{r show_circrnas_2reads_2methods_sample, echo=FALSE, include=TRUE}
circ.2reads.at.least <- circrnas.gtf[RPM > 0 , .N, 
                                     by = .(sample_id, gene_id)][, .(above_min_reads = .N), 
                                                                 by = sample_id]
colnames(circ.2reads.at.least)[colnames(circ.2reads.at.least) == "above_min_reads"] <- paste0("With at least ",
                                                                                              min_reads, " reads")

coln <- paste0("With at least ", min_reads, " reads and ", min_methods, " methods")
circ.2reads.at.least.2methods.at.least <- circrnas.morethan2methods.medrpm[, .N, 
                                                                           by = .(sample_id, circ_id)][
                                                                             , .(reliable = .N),
                                                                             by = sample_id]
colnames(circ.2reads.at.least.2methods.at.least)[colnames(circ.2reads.at.least.2methods.at.least) == "reliable"] <- coln
reliable.circ.tab <- merge(circ.2reads.at.least, circ.2reads.at.least.2methods.at.least, by = "sample_id")

#kable(reliable.circ.tab)
datatable(reliable.circ.tab, 
          rownames = F, 
          style = "bootstrap", class = "compact display", 
          caption = "", 
          fillContainer = F, autoHideNavigation = T, options = list(searching = F))
```

```{r plot_circrnas_2reads_2methods_sample, echo=FALSE, include=TRUE, fig.width=12}

reliable.circ.tab.long <- melt(data = reliable.circ.tab, id.vars = "sample_id", 
                               variable.name = "Filter", value.name = "count")
reliable.circ.tab.long.d <- merge(reliable.circ.tab.long, intgroup.dt, 
                                  by = "sample_id")[order(condition, sample_id)]
reliable.circ.tab.long.d$sample_id <- factor(reliable.circ.tab.long.d$sample_id, 
                                             levels =  unique(reliable.circ.tab.long.d$sample_id),
                                             ordered = T)

reliable.circ.barplot <- ggplot(data = reliable.circ.tab.long.d, 
                                mapping = aes(x = sample_id, y = count,
                                              fill = sample_id)) + 
  geom_bar(stat = "identity", width = .7, aes(colour = sample_id), position = "dodge") + 
  geom_text(stat='identity', aes(label= count), vjust=-0.3, size=default.font.size*(5/14)) +
  facet_wrap(facets = ~ Filter) + 
    ggtitle("CircRNAs per sample") + 
    xlab("") + 
    ylab("Number of circRNAs") + 
    theme_bw() + 
    theme(plot.title = element_text(hjust = 0.5))
## compute limits to remove space from x-axis. Add a 10% increase to the top limit
reliable.circ.barplot.limits <- c(0, max(reliable.circ.tab.long$count)*1.1)
reliable.circ.barplot <- reliable.circ.barplot + 
    guides(fill = FALSE, color = FALSE) +
    theme(text = element_text(size=default.font.size), 
        axis.text.x = element_text(angle=45, hjust=1)) + 
    scale_y_continuous(expand = c(0, 0), limits = reliable.circ.barplot.limits)

reliable.circ.barplot + 
    scale_fill_manual(values = setNames(intgroup.dt[, color], nm = intgroup.dt[, sample_id])) +
    scale_color_manual(values = setNames(intgroup.dt[, hue], nm = intgroup.dt[, sample_id]))

```

## Reliable circRNAs gene annotation overlap

The following analysis considers the __reliable circRNAs__, which are the `r circrnas.morethan2methods.medrpm.table[, .N]` circRNAs detected with at least `r min_reads` reads and by at least `r min_methods` methods. 

The table below indicates the amount of circRNAs overlapping gene annotation according to backsplice start/end coordinates: _exon_ ( _intron_, _intergenic_ ) if both start and end overlap exon (intron, not annotated region); _exon,intron_ if the start overlaps an exon and the end overlaps an intron (and viceversa, the order is not respected in the notation); _exon|intergenic_ or _intergenic|intron_ similarly to the previous case (bar instead of the comma). Other labels occur when circRNAs overlap multiple genes: for instance, _exon,intron|intron_ means that for (at least) one gene the backsplice is mixed (left of the bar) and for another gene the backsplice overlaps only intron(s) (right part of the bar).   

```{r show circrnas categories tab, echo=FALSE, include=TRUE}
# circrnas.morethan2methods.medrpm$sorted_label <- sapply(circrnas.morethan2methods.medrpm$label, 
#                                                         function(x)paste0(sort(strsplit(x = x, 
#                                                                                         split = "|", 
#                                                                                         fixed = T)[[1]]), 
#                                                                           collapse = "|"))
circrnas.morethan2methods.medrpm$sorted_label <- circrnas.morethan2methods.medrpm$label

circrna.categories.tab <- circrnas.morethan2methods.medrpm[
    , .N, by = .(circ_id, sorted_label)][
        , .N, by = sorted_label][
            order(-N), .(Category = sorted_label, "All samples" = N)]

## by sample
if(nrow(circrnas.morethan2methods.medrpm) > 0){
    circrna.categories.tab.ext <- dcast(circrnas.morethan2methods.medrpm[
        , .N, by = .(circ_id, sorted_label, sample_id)][
            , .N, by = .(sorted_label, sample_id)], 
        formula = sorted_label ~ sample_id, value.var = "N", fill = 0)
    
    circrna.categories.tab.ext <- merge(circrna.categories.tab, 
                                        circrna.categories.tab.ext, 
                                        by.x = "Category", by.y = "sorted_label", all = T)
    ## by condition
    circrna.categories.cond.tab <- dcast(merge(circrnas.morethan2methods.medrpm[
        , .N, by = .(circ_id, sorted_label, sample_id)],
        intgroup.dt[, .(condition, sample_id)], by = "sample_id")[
            , .N, by = .(condition, sorted_label)], 
        formula = sorted_label ~ condition, value.var = "N", fill = 0)
    
    circrna.categories.tab.ext <- merge(circrna.categories.tab.ext, circrna.categories.cond.tab,
                                        by.x = "Category", by.y = "sorted_label", all = T)[order(-`All samples`),]
    
    ## TABLE of circRNA category counts
    datatable(data = circrna.categories.tab.ext,
              rownames = F, 
              style = "bootstrap", class = "compact display", 
              caption = "Number of circRNAs according to backsplice overlap with gene annotation", 
              fillContainer = F, autoHideNavigation = T, options = list(searching = F))
}else{
    print("No reliable circRNAs found :(")
}
```

In the following, circRNA categories are grouped into three main classes: _exonic_, _intronic_, and _intergenic_. We assigned the class _exonic_ when _exon_ appears in the category. For instance, _exon|intergenic_ class is grouped into _exonic_. If not _exonic_, the class is grouped into _intronic_ when _intron_ appears among the categories (and none _exon_): for instance, _intergenic,intron_ is grouped into _intronic_; _exon,intron_ is NOT grouped into _intronic_ since it is grouped into _exonic_. The _intergenic_ class groups only _intergenic_ categories.  

```{r show circrnas classes tab, echo=FALSE, include=TRUE}
circ.cat.cond.xpr <- merge(circrnas.morethan2methods.medrpm[
    , .(circ_id, medRPM, sample_id, sorted_label)], 
    intgroup.dt[, .(condition, sample_id)], by = "sample_id")

circ.cat.cond.xpr$simple_label <- sapply(circ.cat.cond.xpr$sorted_label, 
                                         simplify_circrna_labels)

## TABLE
## all samples together
circrna.classes.tab <- circ.cat.cond.xpr[
    , .N, by = .(circ_id, simple_label)][
        , .N, by = simple_label][
            order(-N), .(Class = simple_label, "All samples" = N)]

## by sample
circrna.classes.tab.ext <- dcast(circ.cat.cond.xpr[
    , .N, by = .(circ_id, simple_label, sample_id)][
        , .N, by = .(simple_label, sample_id)],
    formula = simple_label ~ sample_id, value.var = "N", fill = 0)

circrna.classes.tab.ext <- merge(circrna.classes.tab,
                                    circrna.classes.tab.ext,
                                    by.x = "Class", by.y = "simple_label", all = T)

## by condition
circrna.classes.cond.tab <- dcast(merge(circ.cat.cond.xpr[
    , .N, by = .(circ_id, simple_label, sample_id)],
    intgroup.dt[, .(condition, sample_id)], by = "sample_id")[
        , .N, by = .(condition, simple_label)],
    formula = simple_label ~ condition, value.var = "N", fill = 0)

circrna.categories.tab.ext <- merge(circrna.classes.tab.ext, circrna.classes.cond.tab,
                                    by.x = "Class", by.y = "simple_label", all = T)[order(-`All samples`),]

## TABLE of circRNA category counts
datatable(data = circrna.categories.tab.ext,
          rownames = F,
          style = "bootstrap", class = "compact display",
          caption = "Number of circRNAs according to backsplice overlap with gene annotation (classes)",
          fillContainer = F, autoHideNavigation = T, 
          options = list(searching = F, paging = F, info = F))

```

```{r show circrnas categories plots, echo=FALSE, include=TRUE}
## PLOTS
## boxplot of circRNA expression divided by circRNA category and , possibly, grouped by condition
## just group by category
circrna.cat.xpr.boxplot <- ggplot(data = circ.cat.cond.xpr, 
                                             mapping = aes(x = simple_label, y = medRPM, fill = simple_label)) + 
  geom_boxplot(notch = F) + scale_y_log10() + xlab(NULL) + ylab("RPM") + 
    scale_fill_discrete("Category") +
  ggtitle("CircRNAs' category\nexpression") + theme_bw()
circrna.cat.xpr.boxplot <- circrna.cat.xpr.boxplot + 
  theme(text = element_text(size=default.font.size), 
        #axis.text.x = element_text(angle=45, hjust=1), 
        plot.title = element_text(hjust = 0.5), 
        legend.position = "bottom")

## group by condition
circrna.cat.xpr.per.cond.boxplot <- ggplot(data = circ.cat.cond.xpr, 
                                             mapping = aes(x = condition, y = medRPM, fill = simple_label)) + 
  geom_boxplot(notch = F) + scale_y_log10() + xlab(NULL) + ylab("RPM") + 
    scale_fill_discrete("Category") +
  ggtitle("CircRNAs' category\nexpression") + theme_bw()
circrna.cat.xpr.per.cond.boxplot <- circrna.cat.xpr.per.cond.boxplot + 
  theme(text = element_text(size=default.font.size), 
        #axis.text.x = element_text(angle=45, hjust=1), 
        plot.title = element_text(hjust = 0.5), 
        legend.position = "bottom")

multiplot(circrna.cat.xpr.boxplot, circrna.cat.xpr.per.cond.boxplot, cols = 2)

## show all samples
circrna.cat.xpr.per.sample.boxplot <- ggplot(data = circ.cat.cond.xpr, 
                                             mapping = aes(x = sample_id, y = medRPM, fill = simple_label)) + 
  geom_boxplot(notch = F) + scale_y_log10() + 
    facet_grid(facets = . ~ condition, drop = T, scales = "free_x") + xlab(NULL) + ylab("RPM") + 
    scale_fill_discrete("Category") +
  ggtitle("CircRNAs' category\nexpression per sample") + theme_bw()
circrna.cat.xpr.per.sample.boxplot <- circrna.cat.xpr.per.sample.boxplot + 
  theme(text = element_text(size=default.font.size), 
        axis.text.x = element_text(angle=45, hjust=1), 
        plot.title = element_text(hjust = 0.5), 
        legend.position = "bottom")
circrna.cat.xpr.per.sample.boxplot

```

## CircRNAs expressed per gene

Only genes for which the circRNA has label _exonic_ or _intronic_ were considered. The _intergenic\_spanning\_gene_ circRNA-overlapping genes were not considered.

```{r circrnas_per_gene, echo=FALSE, include=TRUE}
## Number of circRNAs per gene
# this code does NOT count genes for which circRNA label is intergenic_spanning_gene!
# circRNAs.to.gene <- subset(circ_to_gene[, .(.N, label = paste0(unique(label), collapse = "|")), 
#                                          by = .(chr, circ_start, circ_end, strand, gene_id, gene_name)][
#                                              gene_id != ".", 
#                                              .(circ_id = paste0(chr, ":", circ_start,  "-", circ_end, ":", strand), 
#                                                gene_id, gene_name, label)], 
#                             circ_id %in% circrnas.morethan2methods.medrpm[
#                                 , .N ,by = circ_id][, circ_id])[label != "intergenic_spanning_gene"]
circRNAs.to.gene <- subset(circ_to_gene[gene_id != "."], 
                           circ_id %in% circrnas.morethan2methods.medrpm.table$circ_id)

## count circRNAs per gene and set the list of circRNAs of the gene
n.circ.per.gene <- circRNAs.to.gene[, .(n_circRNAs = .N, 
                                        circ_ids = paste0(unique(circ_id), collapse = "|")), 
                                    by = .(gene_id, gene_name)][order(-n_circRNAs)]

## save number of circRNAs per gene into a file
circRNAs_per_gene.file <- file.path(results.dir, "circRNAs_per_gene.csv")
write.csv(x = n.circ.per.gene, 
          file = circRNAs_per_gene.file, 
          row.names = F)


circRNAs.per.gene <- circRNAs.to.gene[, .(circRNAs_per_gene = .N),
                                      by = gene_id][order(-circRNAs_per_gene)]

```

Number of genes overlapping the `r circrnas.morethan2methods.medrpm.table[, .N]` reliable circRNAs: `r n.circ.per.gene[, .N]`

Number of circRNAs expressed by each gene, with the respective circRNAs IDs, are reported in file <a href="`r basename(circRNAs_per_gene.file)`">`r basename(circRNAs_per_gene.file)`</a> (only genes expressing circRNAs are reported).  

```{r intergenic spanning genes, echo=FALSE, include=TRUE}
# intergenic_spanning_gene_circrnas <- subset(circ_to_gene[, .(.N, label = paste0(unique(label), collapse = "|")), 
#                     by = .(chr, circ_start, circ_end, strand, gene_id, gene_name)][
#                         gene_id != ".", 
#                         .(circ_id = paste0(chr, ":", circ_start,  "-", circ_end, ":", strand), 
#                           gene_id, gene_name, label)], 
#        circ_id %in% circrnas.morethan2methods.medrpm[
#            , .N ,by = circ_id][, circ_id])[label == "intergenic_spanning_gene"]

# Genes that are spanned by circRNA backsplices are `r intergenic_spanning_gene_circrnas[, .N, by = gene_id][, .N]` and involve `r intergenic_spanning_gene_circrnas[, .N, by = circ_id][, .N]` circRNAs. Note that these circRNAs may be included in the count of circRNAs per gene when there are multiple genes annotated in the same locus.  

```


### Distribution of number of circRNAs per gene  

```{r plot_circrnas_per_gene, echo=FALSE, include=TRUE, fig.width=12}
## quartiles
kable(data.frame(Value = unclass(summary(circRNAs.per.gene$circRNAs_per_gene))))

## barplot
circRNAs.per.gene.plot <- ggplot(data = circRNAs.per.gene, mapping = aes(x = factor(circRNAs_per_gene))) + 
  geom_bar(stat = "count") + ggtitle("CircRNAs per gene") + xlab("Number of circRNAs") + ylab("Number of genes") + 
  theme_bw()
## compute limits to remove space from x-axis. Add a 10% increase to the top limit
circRNAs.per.gene.plot.limits <- c(0, max(circRNAs.per.gene[, .N, by=circRNAs_per_gene][, N])*1.1)
circRNAs.per.gene.plot <- circRNAs.per.gene.plot + 
  theme(text = element_text(size=default.font.size), axis.text.x = element_text(angle=90, hjust=1)) + 
  scale_y_continuous(expand = c(0, 0), limits = circRNAs.per.gene.plot.limits)
circRNAs.per.gene.plot + theme(plot.title = element_text(hjust = 0.5))

# # compute lower and upper whiskers
# ylim_circRNAs.per.gene = boxplot.stats(circRNAs.per.gene$circRNAs_per_gene)$stats[c(1, 5)]
# # scale y limits based on ylim1
# circRNAs.per.gene.boxplot <- ggplot(data = circRNAs.per.gene, mapping = aes(x = "", y = circRNAs_per_gene)) + 
#   geom_boxplot(notch = F, varwidth = T, width = 0.3) + coord_cartesian(ylim = ylim_circRNAs.per.gene*1.05) + xlab("") + 
#   ggtitle("CircRNAs per gene (outliers removed)") + theme_bw() + 
#   theme(text = element_text(size=default.font.size))
# 
# multiplot(circRNAs.per.gene.plot, circRNAs.per.gene.boxplot, cols = 2)
```

### Distribution of number of circRNAs per gene, for each sample

```{r plot_circrnas_per_gene_per_sample, echo=FALSE, include=TRUE, fig.width=12}
## Number of circRNA per gene, discriminating each sample
circRNAs.to.gene.per.sample <- merge(circrnas.morethan2methods.medrpm[, .(circ_id, sample_id)], 
                                      circRNAs.to.gene[, .(circ_id, gene_id, gene_name)], 
                                     by = "circ_id")

n.circ.per.gene.per.sample <- circRNAs.to.gene.per.sample[
    , .(n_circRNAs = .N, circ_ids = paste0(unique(circ_id), collapse = "|")), 
    by = .(sample_id, gene_id, gene_name)][order(sample_id, -n_circRNAs)]

## save circRNAs per gene per sample
circRNAs_per_gene.per.sample.file <- file.path(results.dir, "circRNAs_per_gene_per_sample.csv")
write.csv(x = n.circ.per.gene.per.sample,
          file = circRNAs_per_gene.per.sample.file,
          row.names = F)

circRNAs.per.gene.per.sample <- n.circ.per.gene.per.sample[, .(gene_id, gene_name, 
                                                               circRNAs_per_gene = n_circRNAs, 
                                                               sample_id)]

## quartiles (per sample)
kable(sapply(X = split(circRNAs.per.gene.per.sample, circRNAs.per.gene.per.sample$sample_id), 
             FUN = function(x){summary(x$circRNAs_per_gene)}), caption = "CircRNAs per gene distribution")


circRNAs.per.gene.per.sample$sample_id <- factor(circRNAs.per.gene.per.sample$sample_id, 
                                                 levels = meta[order(condition, sample_id), sample_id], 
                                                 ordered = T)

## barplot
circRNAs.per.gene.per.sample.plot <- ggplot(data = circRNAs.per.gene.per.sample, 
                                            mapping = aes(x = factor(circRNAs_per_gene),
                                                          fill = sample_id, 
                                                          color = sample_id)) + 
    geom_bar(stat = "count") + 
    facet_wrap(facets = ~ sample_id, scales = "free") + 
    ggtitle("CircRNAs per gene") + xlab("Number of circRNAs") + ylab("Number of genes") + 
    theme_bw()
circRNAs.per.gene.per.sample.plot <- circRNAs.per.gene.per.sample.plot + 
    theme(text = element_text(size=default.font.size), axis.text.x = element_text(angle=90, hjust=1))
if(meta_file != ""){
    circRNAs.per.gene.per.sample.plot <- circRNAs.per.gene.per.sample.plot + 
        scale_fill_manual(values = setNames(intgroup.dt[, color], nm = intgroup.dt[, sample_id])) +
        scale_color_manual(values = setNames(intgroup.dt[, hue], nm = intgroup.dt[, sample_id]))
}
circRNAs.per.gene.per.sample.plot + 
    theme(plot.title = element_text(hjust = 0.5)) + 
    guides(fill = FALSE, color = FALSE)
```

Number of circRNAs expressed per gene, per each sample, have been saved in file <a href="`r basename(circRNAs_per_gene.per.sample.file)`">`r basename(circRNAs_per_gene.per.sample.file)`</a>. 

### Distribution of number of circRNAs per gene, grouped per condition

```{r plot_circrnas_per_gene_per_condition, echo=FALSE, include=TRUE, fig.width=12, fig.height=8}
circRNAs_per_gene.per.cond.file <- "Not applicable to this settings"
circRNAs.to.gene.per.sample <- merge(circRNAs.to.gene.per.sample, 
                                     intgroup.dt[, .(sample_id, condition)], 
                                     by = "sample_id")
if(intgroup.dt[, .N, by=condition][, .N] > 1){
    
    # combined_gtf <- merge(combined_gtf, intgroup.dt[, .(sample_id, condition)], by = "sample_id")
    ## 
    n.circ.per.gene.per.condition <- unique(circRNAs.to.gene.per.sample[, .(circ_id, 
                                                                            gene_id, 
                                                                            gene_name, 
                                                                            condition)])[, .(n_circRNAs = .N,            circ_ids = paste0(unique(circ_id), 
                              collapse = "|")), 
                              by = .(condition, gene_id, gene_name)][order(condition, -n_circRNAs)]
    
    circRNAs.per.gene.per.condition <- n.circ.per.gene.per.condition[, .(gene_id, gene_name, 
                                                                         circRNAs_per_gene = n_circRNAs,
                                                                         condition)]
    
    circRNAs_per_gene.per.cond.file <- file.path(results.dir, "circRNAs_per_gene_per_condition.csv")
    write.csv(x = n.circ.per.gene.per.condition,
              file = circRNAs_per_gene.per.cond.file,
              row.names = F)
    
    ## quartiles per condition TABLE
    kable(sapply(X = split(circRNAs.per.gene.per.condition, circRNAs.per.gene.per.condition$condition), 
                 FUN = function(x){summary(x$circRNAs_per_gene)}), 
          caption = "CircRNAs per gene distribution")
}
if(intgroup.dt[, .N, by=condition][, .N] > 1){
    ## barplot per condition
    circRNAs.per.gene.per.condition.plot <- ggplot(data = circRNAs.per.gene.per.condition, 
                                                   mapping = aes(x = factor(circRNAs_per_gene), 
                                                                 fill = condition)) + 
        geom_bar(stat = "count") + facet_wrap(facets = ~ condition, scales = "free", 
                                              nrow = intgroup.dt[, .N, by = condition][, .N]) + 
        ggtitle("CircRNAs per gene") + xlab("Number of circRNAs") + ylab("Number of genes") + 
        theme_bw() + scale_fill_manual(values = setNames(unique(intgroup.dt[, hue]), 
                                                         nm = unique(intgroup.dt[, condition])),
                                       guide = FALSE)
    circRNAs.per.gene.per.condition.plot <- circRNAs.per.gene.per.condition.plot + 
        theme(text = element_text(size=default.font.size), axis.text.x = element_text(angle=90, hjust=1))
    circRNAs.per.gene.per.condition.plot + 
        theme(plot.title = element_text(hjust = 0.5))
}
```

Number of circRNAs expressed per gene, grouping by condition, have been saved in file <a href="`r basename(circRNAs_per_gene.per.cond.file)`">`r basename(circRNAs_per_gene.per.cond.file)`</a>. 

## CircRNA expression vs number of circRNAs isoforms per gene

The following plots show circRNA expression distribution grouping per number of circRNAs expressed by gene. This is to analyze whether the expression of circRNAs changes if they are generated from genes expressing many circRNAs. In other words, whether the expression level of circRNAs is correlated to the number of circRNA isoforms expressed by a gene.  

Note: boxes are drawn with widths proportional to the square-roots of the number of observations in the groups

```{r CircRNA expression vs circRNAs expressed per gene, include=FALSE}
circ.expr.to.circ.per.gene.per.sample <- merge(circRNAs.to.gene.per.sample, 
                                               circrna.rpms[, .(circ_id = gene_id, 
                                                                sample_id, medRPM)], 
                                               by = c("circ_id", "sample_id"), 
                                               all.x = T, all.y = F)

## discriminate per sample
circ.expr.to.circ.per.gene.per.sample[, circRNAs_per_gene := .N, by = .(sample_id, gene_id)]
```

```{r CircRNA expression vs circRNAs expressed per gene plots, fig.width=12, fig.height=8}
## boxplot
circ.expr.to.circ.per.gene.per.sample.plot <- ggplot(data = circ.expr.to.circ.per.gene.per.sample, 
                                                     mapping = aes(x = factor(circRNAs_per_gene), y = medRPM)) + 
    geom_boxplot(varwidth = T, aes(fill = sample_id)) + 
    scale_y_log10() + facet_wrap(facets = ~ sample_id, scales = "free_x")
## add decorations to plot
circ.expr.to.circ.per.gene.per.sample.plot <- circ.expr.to.circ.per.gene.per.sample.plot + 
    ggtitle("CircRNAs per gene vs circRNA expression") + xlab("Number of circRNAs") + ylab("CircRNA RPM") + 
    theme_bw() + 
    theme(text = element_text(size=default.font.size), axis.text.x = element_text(angle=90, hjust=1))
if(meta_file != ""){
    circ.expr.to.circ.per.gene.per.sample.plot <- circ.expr.to.circ.per.gene.per.sample.plot + 
        scale_fill_manual(values = setNames(intgroup.dt[, color], nm = intgroup.dt[, sample_id]))
}
circ.expr.to.circ.per.gene.per.sample.plot + theme(plot.title = element_text(hjust = 0.5)) + 
    guides(fill = FALSE)

## all samples together: mean expression across samples
circ.expr.to.circ.per.gene <- unique(circ.expr.to.circ.per.gene.per.sample[, .(avgRPM = mean(medRPM)), 
                                                                           by = .(gene_id, circ_id)])[
                                                                               , circRNAs_per_gene := .N, by = gene_id][]
circ.expr.to.circ.per.gene.plot <- ggplot(data = circ.expr.to.circ.per.gene, 
                                          mapping = aes(x = factor(circRNAs_per_gene), y = avgRPM)) + 
    geom_boxplot(varwidth = T) + scale_y_log10()
## add decorations to plot
circ.expr.to.circ.per.gene.plot <- circ.expr.to.circ.per.gene.plot + 
    ggtitle("CircRNAs per gene vs circRNA expression") + xlab("Number of circRNAs") + ylab("CircRNA RPM") + 
    theme_bw() + 
    theme(text = element_text(size=default.font.size), axis.text.x = element_text(angle=90, hjust=1))
circ.expr.to.circ.per.gene.plot + theme(plot.title = element_text(hjust = 0.5)) + 
    guides(fill = FALSE)

if(meta_file != ""){
    ## discriminate per condition: mean expression across samples, within conditions
    circ.expr.to.circ.per.gene.per.condition <- unique(circ.expr.to.circ.per.gene.per.sample[, .(avgRPM = mean(medRPM)), 
                                                                                             by = .(condition, gene_id,
                                                                                                    circ_id)])[
                                                                                                 , circRNAs_per_gene := .N, 
                                                                                                 by = .(condition, gene_id)][]
    circ.expr.to.circ.per.gene.per.condition.plot <- ggplot(data = circ.expr.to.circ.per.gene.per.condition, 
                                                            mapping = aes(x = factor(circRNAs_per_gene), y = avgRPM,
                                                                          fill = condition)) + 
        geom_boxplot(varwidth = T) + scale_y_log10() +  
        facet_wrap(facets = ~ condition, scales = "free", nrow = intgroup.dt[, .N, by = condition][, .N])
    ## add decorations to plot
    circ.expr.to.circ.per.gene.per.condition.plot <- circ.expr.to.circ.per.gene.per.condition.plot + 
        ggtitle("CircRNAs per gene vs circRNA expression") + xlab("Number of circRNAs") + ylab("CircRNA RPM") + 
        theme_bw() + 
        theme(text = element_text(size=default.font.size), axis.text.x = element_text(angle=90, hjust=1))
    
    circ.expr.to.circ.per.gene.per.condition.plot <- circ.expr.to.circ.per.gene.per.condition.plot + 
        scale_fill_manual(values = setNames(unique(intgroup.dt[, hue]), 
                                            nm = unique(intgroup.dt[, condition])),
                          guide = FALSE)
    
    circ.expr.to.circ.per.gene.per.condition.plot + theme(plot.title = element_text(hjust = 0.5))
}
```

# Circular - linear expression

```{r}
## get normalization scaling factor (i.e. clean reads)
sample.depth <-
    fread(read_stats_collect.file)[, .(sample_id = Sample,
                                       seq_depth = as.integer(`Clean reads`))]

circ.scales <- 
    circrnas.gtf[, sum(V6), 
                 by = .(sample_id, 
                        V2)][, .(circ.RPM.scale = median(V1)), 
                             by = sample_id]
```

```{r}
bks_linear_counts.tab.gz <- fread(bks_linear_counts.tab.gz.file)

# if("name" %in% colnames(bks_linear_counts.tab.gz)){
#     bks_linear_counts.tab.gz <- 
#         bks_linear_counts.tab.gz[, c("name", sort(meta$sample_id)), 
#                                  with = F][, lapply(.SD, sum), 
#                                            by = .(circ_id = sub('gene_id "([^"]+)".*', 
#                                                                 "\\1", name))]
if("V1" %in% colnames(bks_linear_counts.tab.gz)){
    bks_linear_counts.tab.gz[, c("sample_id", "chr") := (tstrsplit(V1, ":"))]
    bks_linear_counts.tab.gz[, `:=`(sample_id = sub("_bks_linear_counts.tab$", "",
                                             basename(sample_id)),
                                    circ_id = sub('.*"([^"]+)".*', "\\1", V9))]
    bks_linear_counts.tab.gz[, V1 := NULL]
    bks_linear_counts.tab.gz.m <- 
        bks_linear_counts.tab.gz[, .(lin.reads = sum(V10)), 
                                 by = .(sample_id, circ_id)]
    bks_linear_counts.tab.gz <- dcast(bks_linear_counts.tab.gz, fill = 0,
                                   formula = circ_id ~ sample_id, value.var = "V10",
                                   fun.aggregate = sum, )
        
}else{
    ## DCC uses BED coordinates, we need to convert
    bks_linear_counts.tab.gz[, circ_id := paste0(chr, ":", start+1, "-", end)]
    if("strand" %in% colnames(bks_linear_counts.tab.gz)){
        bks_linear_counts.tab.gz[, circ_id := paste0(circ_id, ":", strand)]
    }else{
        bks_linear_counts.tab.gz[, circ_id := paste0(circ_id, ":", c("+", "-"))]
        bks_linear_counts.tab.gz <- 
            bks_linear_counts.tab.gz[circ_id %in% circrnas.gtf[, unique(gene_id)],
                                     c("circ_id", sort(meta$sample_id)), 
                                     with = F]
    }
    bks_linear_counts.tab.gz.m <- melt(bks_linear_counts.tab.gz, 
                                   id.vars = "circ_id", 
                                   variable.name = "sample_id", 
                                   value.name = "lin.reads")
}
```

```{r}
## save linear expression relative to circRNAs
circrna.lin.xpr.filename <- "circrna.lin.xpr.csv"
write.csv(x = bks_linear_counts.tab.gz, 
          file = file.path(results.dir, circrna.lin.xpr.filename), 
          row.names = F)
```

Linear expression of circRNAs have been saved in file <a href="`r circrna.lin.xpr.filename`">`r circrna.lin.xpr.filename`</a>  


```{r}
scaled.circ <- 
    merge(circrna.rpms[circrnas.morethan2methods],
      circ.scales, 
      by = "sample_id")[, .(circ_id = gene_id, 
                            circ.reads = medRPM*circ.RPM.scale/10^6, 
                            sample_id)]

circ.lin.xpr <- 
    merge(scaled.circ, 
          bks_linear_counts.tab.gz.m, 
          by = c("sample_id", "circ_id"))

circ.lin.xpr <-
    merge(circ.lin.xpr,
          sample.depth,
          by = "sample_id")

circ.lin.xpr[, CLR := (2*circ.reads)/lin.reads]
```

## Circular to linear expression

CLR = circular to linear expression ratio  

```{r, dev='jpeg'}
ggplot(data = circ.lin.xpr, mapping = aes(x = circ.reads*10^6/seq_depth, 
                                          y = lin.reads*10^6/seq_depth)) +
    geom_point(aes(color = CLR)) +
    # geom_smooth(method = "lm", se = F) +
    scale_x_log10("Circular RPM") +
    scale_y_log10("Linear RPM") +
    # coord_fixed(ratio = 1) +
    scale_color_distiller(name = "CLR", palette = "Spectral") +
    ggtitle("Circular to linear expression") +
    theme_bw() + 
    theme(plot.title = element_text(hjust = .5))
```

```{r, dev='jpeg'}
ggplot(data = merge(circ.lin.xpr, intgroup.dt[, .(sample_id, condition)], 
                    by = "sample_id"), 
       mapping = aes(x = circ.reads*10^6/seq_depth, 
                     y = lin.reads*10^6/seq_depth)) +
    geom_point(aes(color = CLR)) +
    # geom_smooth(method = "lm", se = F, aes(color = condition)) +
    facet_wrap(facets = ~ condition) +
    scale_x_log10("Circular RPM") +
    scale_y_log10("Linear RPM") +
    # coord_fixed(ratio = 1) +
    scale_color_distiller(name = "CLR", palette = "Spectral") +
    ggtitle("Circular to linear expression") +
    theme_bw() + 
    theme(plot.title = element_text(hjust = .5))
```


```{r, dev='jpeg'}
ggplot(data = circ.lin.xpr, mapping = aes(x = circ.reads*10^6/seq_depth, 
                                          y = lin.reads*10^6/seq_depth)) +
    geom_point(aes(color = CLR)) +
    # geom_smooth(method = "lm", se = F) +
    facet_wrap(facets = ~ sample_id) +
    scale_x_log10("Circular RPM") +
    scale_y_log10("Linear RPM") +
    # coord_fixed(ratio = 1) +
    scale_color_distiller(name = "CLR", palette = "Spectral") +
    ggtitle("Circular to linear expression") +
    theme_bw() + 
    theme(plot.title = element_text(hjust = .5))
```

## CircRNA expression  to CLR

```{r, dev='jpeg'}
ggplot(data = circ.lin.xpr, mapping = aes(x = circ.reads*10^6/seq_depth, 
                                          y = CLR)) +
    geom_point(aes(color = ifelse(CLR > 1, ">1", ifelse(CLR < 0.5, "<0.5", "0.5<CLR<1")))) +
    scale_x_log10("Circular RPM") +
    scale_y_log10("CLR") +
    # coord_fixed(ratio = 1) +
    scale_color_brewer(name = "CLR threshold", palette = "Set1") +
    ggtitle("Circular expression to CLR") +
    theme_bw() + 
    theme(plot.title = element_text(hjust = .5))
```

```{r, dev='jpeg'}
ggplot(data = merge(circ.lin.xpr, intgroup.dt[, .(sample_id, condition)], 
                    by = "sample_id"), 
       mapping = aes(x = circ.reads*10^6/seq_depth, 
                     y = CLR)) +
    geom_point(aes(color = ifelse(CLR > 1, ">1", ifelse(CLR < 0.5, "<0.5", "0.5<CLR<1")))) +
    facet_wrap(facets = ~ condition) +
    scale_x_log10("Circular RPM") +
    scale_y_log10("CLR") +
    # coord_fixed(ratio = 1) +
    scale_color_brewer(name = "CLR threshold", palette = "Set1") +
    ggtitle("Circular to linear expression") +
    theme_bw() + 
    theme(plot.title = element_text(hjust = .5))
```

```{r, dev='jpeg'}
ggplot(data = circ.lin.xpr, mapping = aes(x = circ.reads*10^6/seq_depth, 
                                          y = CLR)) +
    geom_point(aes(color = ifelse(CLR > 1, ">1", ifelse(CLR < 0.5, "<0.5", "0.5<CLR<1")))) +
    # geom_smooth(method = "lm", se = F) +
    facet_wrap(facets = ~ sample_id) +
    scale_x_log10("Circular RPM") +
    scale_y_log10("CLR") +
    # coord_fixed(ratio = 1) +
    scale_color_brewer(name = "CLR threshold", palette = "Set1") +
    ggtitle("Circular expression to CLR") +
    theme_bw() + 
    theme(plot.title = element_text(hjust = .5))
```


# CircRNAs' linear expression

CircRNA expression by sample have been saved in file <a href="`r circRNA_expression_per_sample.csv.basename`">`r circRNA_expression_per_sample.csv.basename`</a>

## Linear expression distribution

```{r}
circ.lin.xpr <- merge(circ.lin.xpr, meta[, .(sample_id, condition)], by = "sample_id")
```

```{r}
pdt <- circ.lin.xpr[]
## TODO: improve normalization of linear expression
pdt[, CPM := lin.reads*10^6/seq_depth]

ggplot(pdt, aes(x = sample_id, y = CPM)) +
    geom_boxplot(aes(fill = sample_id)) +
    scale_y_log10(name = "Linear CPM") +
    scale_fill_manual(values = setNames(intgroup.dt[, color], 
                                        nm = intgroup.dt[, sample_id]), 
                      guide = F) +
    facet_grid(facets = . ~ condition, drop = T, scales = "free_x", space = "free_x") +
    xlab(NULL) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1), 
          panel.spacing.x = unit(.1, "lines"))
```

## Linearly expressed circRNA genes

```{r}
circ.lin.xpr <- merge(circ.lin.xpr, circ_to_genes, by = "circ_id")
```

```{r}
## number of circRNAs with linear expression, per sample
dt <- circ.lin.xpr[lin.reads > 0, .N, 
                         by = .(sample_id, 
                                circ_id)][, .(`CircRNAs with linear expression` = .N), 
                                          by = .(Sample = sample_id)]
if(nrow(dt) == 0){
    dt <- data.table(Sample = meta$sample_id, 
                             `CircRNAs with linear expression` = 0)
}

## number of circRNAs with no linear expression, per sample
no.lin.xpr <- circ.lin.xpr[lin.reads == 0, .N, 
                         by = .(sample_id, 
                                circ_id)][, .(`CircRNAs with no linear expression` = .N), 
                                          by = .(Sample = sample_id)]
if(nrow(no.lin.xpr) == 0){
    no.lin.xpr <- data.table(Sample = dt$Sample, 
                             `CircRNAs with no linear expression` = 0)
}

dt <- merge(dt, no.lin.xpr, by = "Sample")

datatable(data = dt, caption = "Number of circRNAs with linear expression",
          rownames = F, options = list(searching = T))
```

```{r}
## number of circRNAs with linear expression, per annotation and sample
dt <- circ.lin.xpr[lin.reads > 0, .N, 
                         by = .(sample_id, label,
                                circ_id)][, .N, 
                                          by = .(Sample = sample_id, label)]

if(nrow(dt) == 0){
    dt <- data.table(Sample = meta$sample_id, 
                     exon = 0)
}else{
    dt <- dcast(dt,
                formula = Sample ~ label, value.var = "N")
}

## number of circRNAs with no linear expression, per annotation and sample
no.lin.xpr <- circ.lin.xpr[lin.reads == 0, .N, 
                         by = .(sample_id, label,
                                circ_id)][, .N, 
                                          by = .(Sample = sample_id, label)]
if(nrow(no.lin.xpr) == 0){
    no.lin.xpr <- data.table(Sample = dt$Sample, 
                             exon = 0)
}else{
    no.lin.xpr <- dcast(no.lin.xpr, formula = Sample ~ label, value.var = "N")
}

dt <- merge(dt, no.lin.xpr, by = "Sample", suffixes = c(" lin", " no lin"))

datatable(data = dt, caption = "Number of circRNAs with linear expression",
          rownames = F, options = list(searching = T))
```

# Correlation of circular and linear expression 

```{r}
circ.lin.cor <- 
    circ.lin.xpr[, .(Correlation = cor(circ.reads, 
                                       lin.reads, method = "spearman")), 
                 by = circ_id]

circ.lin.cor.cond <- 
    circ.lin.xpr[, .(Correlation = cor(circ.reads, 
                                       lin.reads, method = "spearman")), 
                 by = .(condition, circ_id)]
```

```{r}
ggplot(circ.lin.cor[, .(Count = .N), by = .(Correlation = round(Correlation, 1))], 
       aes(x = factor(Correlation, 
                      levels = seq(from = -1, to = 1, by = .1), 
                      ordered = T, exclude = NA), 
           y = Count)) + 
    geom_col() + 
    geom_text(label = "", aes(y = Count*1.1)) +
    scale_x_discrete(expand = c(0, 0), drop = F) +
    scale_y_continuous(expand = c(0, 0)) +
    xlab(expression(rho[Spearman])) +
    theme_bw() +
    theme()
```

```{r}
ggplot(circ.lin.cor.cond[, .(Count = .N), 
                         by = .(condition, 
                                Correlation = round(Correlation, 1))], 
       aes(x = factor(Correlation, 
                      levels = seq(from = -1, to = 1, by = .1), 
                      ordered = T, exclude = NA), 
           y = Count)) + 
    geom_col() + 
    geom_text(label = "", aes(y = Count*1.1)) +
    facet_grid(facets = condition ~ ., drop = T, scales = "free_y") +
    scale_x_discrete(expand = c(0, 0), drop = F) +
    scale_y_continuous(expand = c(0, 0)) +
    xlab(expression(rho[Spearman])) +
    theme_bw() +
    theme()
```


```{r}
ggplot(circ.lin.cor, aes(x = "", y = Correlation)) + 
    geom_boxplot() + 
    scale_y_continuous(expand = c(0, 0), limits = c(-1.1, 1.1)) +
    xlab(NULL) +
    ylab(expression(rho[Spearman])) +
    theme_bw() +
    theme(axis.ticks.x = element_blank())
```

```{r}
ggplot(circ.lin.cor, aes(x = ifelse(Correlation > 0, "Positive", "Negative"), 
                         y = abs(Correlation))) + 
    geom_boxplot() + 
    scale_y_continuous(expand = c(0, 0), limits = c(-0.1, 1.1)) +
    xlab(NULL) +
    ylab(expression(rho[Spearman])) +
    theme_bw() +
    theme(axis.ticks.x = element_blank())
```


```{r}
ggplot(circ.lin.cor.cond, aes(x = "", y = Correlation)) + 
    geom_boxplot() + 
    geom_text(aes(label = "", y = 1.1)) +
    facet_grid(facets = . ~ condition, drop = T, scales = "free_x", space = "free_x") +
    scale_y_continuous(expand = c(0, 0), limits = c(-1.1, 1.1)) +
    scale_fill_manual(values = setNames(unique(intgroup.dt[, hue]), 
                                        nm = unique(intgroup.dt[, condition])))+
    xlab(NULL) +
    ylab(expression(rho[Spearman])) +
    theme_bw() +
    theme(axis.ticks.x = element_blank(), 
          panel.spacing.x = unit(.1, "lines"))
```

```{r}
ggplot(circ.lin.cor.cond, aes(x = ifelse(Correlation > 0, "Positive", "Negative"), 
                         y = abs(Correlation))) +
    geom_boxplot() + 
    geom_text(aes(label = "", y = 1.1)) +
    facet_grid(facets = . ~ condition, drop = T, scales = "free_x", space = "free_x") +
    scale_y_continuous(expand = c(0, 0), limits = c(-0.1, 1.1)) +
    scale_fill_manual(values = setNames(unique(intgroup.dt[, hue]), 
                                        nm = unique(intgroup.dt[, condition])))+
    xlab(NULL) +
    ylab(expression(rho[Spearman])) +
    theme_bw() +
    theme(axis.ticks.x = element_blank(), 
          panel.spacing.x = unit(.1, "lines"))
```


# Session info

This page was generated with the following packages version

```{r session, echo=FALSE}
sessionInfo()
```
