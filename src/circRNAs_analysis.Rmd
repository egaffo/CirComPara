---
title: "CirComPara: detection and analysis of circular RNAs"
date: "`r Sys.Date()`"  
output: 
  html_document: 
    keep_md: no
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: 
      collapsed: false
      smooth_scroll: true
    theme: "readable"
---

# CirComPara results summary

CirComPara analysis results are presented in this page. Different sections display aggregated data in tables and figures. Raw and integrated results were saved in comma separated (CSV) files. 

```{r global_options, include=FALSE}
## variables to be defined in parent frame
# results.dir
# circrnas.gtf.file
# combined_gtf_file# 
# gene_meta_file
# gene_fpkm_file
# min_methods ## minimum number of methods detecting a circRNA to define it "reliable"
# min_reads
# meta_file

dir.create(path = results.dir, showWarnings = F, recursive = T)
knitr::opts_chunk$set(fig.width = 6, 
                      fig.height = 4, 
                      dev = c('svglite', 'png'), 
                      fig.pos = "center",
                      fig.path = file.path(results.dir, paste0('Figs', .Platform$file.sep)),
                      echo = FALSE, 
                      warning = FALSE, 
                      message = FALSE)
library(knitr)
library(data.table)
library(ggplot2)
library(RColorBrewer)
library(scales)
library(DT)
```


```{r utility_functions, echo=FALSE, include=FALSE}
# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)
  
  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)
  
  numPlots = length(plots)
  
  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }
  
  if (numPlots==1) {
    print(plots[[1]])
    
  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    
    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
      
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

# Compute label for a circRNA according to gene overlaps
#
# This function serves to categorize backsplices according to the positions
# relative to gene/exons.
# An "error region" of the exon/backsplice coordinates could be considered
# by setting flank > 0
# We define three backsplice categories:
# 1. Intergenic: both start and end are outside any gene
# 2. Intronic: both end are in intron(s)
# 3. Exonic: either start or end is in exon(s)
#
# - backsplice: a two elements integer array with start and end of the circRNA
# - exon:       a two elements integer array with start and end of the exon
# - gene:       a two elements integer array with start and end of the gene
# - flank:      the number of flanking bases allowed for the backspice coordinates
#
label.backsplice <- function(backsplice, exon, gene, flank = 0){
  
  gene_start <- gene[1] - flank
  gene_end <- gene[2] + flank
  exon_start <- exon[1] - flank
  exon_end <- exon[2] + flank
  circ_start <- backsplice[1]
  circ_end <- backsplice[2]
  
  category <- "undefined"
  if(exon_start < 0){
    category <- "intergenic"
  }else{
    if(circ_start >= gene_start | circ_end <= gene_end){ # are we inside a gene?
      category <- "intronic"
      if(circ_start >= exon_start | circ_end <= exon_end){ # are we within an exon?
        category <- "exonic"
      }
    }else{
      # we are not inside a gene, but an exon is overlapped
      if(circ_start < gene_start & circ_end > gene_end){ # just double check we are completely outside a gene
        category <- "intergenic_spanning_gene"
      }
    }
  }
  category
}

# Refine labelling for a circRNA
#
# - labels_list: the list of labels assigned to i circRNA ID
#
refine_label <- function(labels_list){
  
  if("exonic" %in% labels_list){
    label <- "exonic"
  }else{
    if("intronic" %in% labels_list){
      label <- "intronic"
    }else{
      if("intergenic" %in% labels_list){
        label <- "intergenic"
      }else{
        label <- paste0(sort(unique(labels_list)), collapse = ",")
      }
    }
  }
  label
}

# reduce complexity of labels. Simplify into exonic, intronic, intergenic 
# categories. The function simply assign "exonic" if at least one exon 
# overlaps the backsplice; otherwise, "intron" if an intron overlaps; 
# otherwise, "intergenic" for either intergenic and intergenic_spanning_gene;
# "other" as a backfall label that should not appear.
# - label: the collapsed labels for a circRNA
simplify_circrna_labels <- function(label){
    lab <- "other"
    if(grepl("exon", label)){
        lab <- "exonic"
    }else{
        if(grepl("intergenic", label)){
            lab <- "intergenic"
        }
        if(grepl("intron", label)){
            lab <- "intronic"
        }
    }
    lab
}
```

```{r sample_summary, echo=FALSE, include=FALSE}
#"TODO"
## meta <- fread(meta.file)
## read.preprocessing
```

<!-- 
TODO: Considered samples: list (+ altri dati?)
(insert summary per sample? E.g. total reads or other statistics that could describe sample differences?)
-->

```{r load_circrnas, echo=FALSE, include=FALSE}
## read circRNA results: filter low expressed (less than min_reads reads) circRNAs
colClasses <- c("factor", "factor", "character", "integer", "integer", "integer", "factor", "character", "character")
circrnas.gtf <- fread(circrnas.gtf.file, data.table = T, colClasses = colClasses)[V6 >= min_reads]
V9pattern <- '.*gene_id "([^"]*)".*transcript_id "([^"]*)".*'
V9newCols <- c("gene_id", "transcript_id")
exists_circrnas <- FALSE
if(nrow(circrnas.gtf) > 0){
  exists_circrnas <- TRUE
  circrnas.gtf[, `:=` (sample_id = sub('.*sample_id "([^"]*)".*', "\\1", V9))
               ][, (V9newCols) := tstrsplit(sub(V9pattern, "\\1@\\2", V9), "@", fixed=TRUE)
                 ][, V9 := NULL]
  
  # if(fix_testrealign){
  #   setkey(circrnas.gtf, V2)
  #   circrnas.gtf["testrealign", V4 := V4-1]
  #   circrnas.gtf["testrealign", `:=`(gene_id = paste0(V1, ":", V4, "-", V5, ":", V7), 
  #                                 transcript_id = paste0(V1, ":", V4, "-", V5, ":", V7, ".", sample_id))]
  # }
  
  # ## read circRNA-method per sample normalization factors
  # norm.factors.file <- "/home/enrico/Scrivania/QKI_anhal/analysis/circRNA_collection/circrna_maps_counts.txt"
  # norm.factors <- as.data.table(scan(file = norm.factors.file, what = list("character", "integer"), sep = "\n"))
  # norm.factors[, `:=` (sample_id = sub('.*samples/([^/]*).*', "\\1", V1),
  #                      method = tolower(gsub("_out|_", "", sub('.*circRNAs/([^/]*).*', "\\1", V1))),
  #                      norm_factor = as.integer(V2))][, `:=` (V1 = NULL, V2 = NULL)]
  # setkey(x = norm.factors, sample_id, method)
  # ## apply normalization factors: define normalized expression as RPM (Reads Per Million mapped reads)
  # setkey(x = circrnas.gtf, sample_id, V2)
  # circrnas_expression <- norm.factors[circrnas.gtf][, RPM := (V6*10^6)/norm_factor]
  
  ## normalize circrna reads by the amount of backsplice Reads in method (Per Million reads - RPM)
  circrnas.gtf[, RPM := (V6/sum(V6))*10^6, by = .(sample_id, V2)]
  ## compute median of normalized value
  circrna.rpms <- data.table::dcast(data = circrnas.gtf, 
                                    formula = sample_id + gene_id + V1 + V4 + V5 + V7 ~ V2, 
                                    value.var = "RPM", fill = 0)
  ## account also 0s for the computation of the meadian RPM
  #circrna.rpms$medRPM <- apply(X = circrna.rpms[, 7:ncol(circrna.rpms), with = F], MARGIN = 1, FUN = median)
  ## remove 0s from computation of the meadian RPM
  circrna.rpms <- merge(circrna.rpms, 
                        circrnas.gtf[, .(medRPM = median(RPM)), by = .(sample_id, gene_id)], 
                        by = c("sample_id", "gene_id"))
}else{
  circrnas.gtf[, `:=`(RPM="", gene_id="")]
  circrna.rpms <- circrnas.gtf
  circrna.rpms.genes <- circrna.rpms
  circrna.rpms.genes[, `:=`(circ_id="", gene_ids="", gene_names="", label="", sample_id="", chr="", V1="", start="", V4="", 
                            end="", V5="", strand="", V7="", medRPM="")]
}

```

```{r load_circrna_gene_overlaps, echo=FALSE, include=FALSE}
## retrieve and attach gene symbols and gene_ids: use only exons hit by the backsplice coordinates 
# colClasses <- c("factor", "factor", "character", "integer", "integer", "integer", "factor", "character", "character",
#                 "factor", "factor", "character", "integer", "integer", "character", "factor", "character", "character")
# colClasses <- list(factor = c(1, 4, 6, 7, 10), 
#                    integer = c(2L, 3L, 8L, 9L), 
#                    character = c(5, 11))
#colToDrop <- c("V3", "V8", "V11", "V12", "V15", "V17")
#combined_gtf <- fread(paste0('zcat ', combined_gtf_file), data.table = T, colClasses = colClasses, drop = colToDrop)
combined_gtf <- fread(paste0('zcat ', combined_gtf_file), data.table = T, 
                      # colClasses = colClasses, 
                      drop = c(2,3,6,8,11,15,17))
exists_gene_overlaps <- FALSE
if(nrow(combined_gtf) > 0){
  exists_gene_overlaps <- TRUE
  # if(fix_testrealign){
  #   setkey(combined_gtf, V2)
  #   combined_gtf["testrealign", V4 := V4-1]
  # }
  combined_gtf[, `:=`(circ_id = sub('.*gene_id "([^"]*)".*', '\\1', V9),
                      gene_id = sub('.*gene_id "([^"]*)".*', "\\1", V18), 
                      gene_name = ifelse(grepl('gene_name', V18, fixed = T), 
                                         sub('.*gene_name "([^"]*)".*', "\\1", 
                                             V18), "."),
                      # sample_id = sub('.*sample_id "([^"]*)".*', "\\1", V9),
                      chr = V1, 
                      circ_start = as.integer(V4), 
                      circ_end = as.integer(V5), 
                      strand = V7,
                      gene_chr = V10, 
                      exon_start = as.integer(V13), 
                      exon_end = as.integer(V14), 
                      exon_strand = V16)
               ][, `:=`(V1 = NULL, V4 = NULL, V5 = NULL, V7 = NULL, V9 = NULL, 
                        V10 = NULL, V13 = NULL, V14 = NULL, V16 = NULL, V18 = NULL)]
  # combined_gtf[, `:=`(gene_start = min(exon_start), 
  #                     gene_end = max(exon_end)), 
  #              by = gene_id]
  combined_gtf[V12 == ".", V12 := "intergenic"]
  
  # circ_to_gene <- combined_gtf[, .(counts = .N), by = .(chr, circ_start, circ_end, strand, 
  #                                                       exon_start, exon_end, gene_id, gene_name, 
  #                                                       gene_start, gene_end)][, counts := NULL]
  # 
  # 
  # 
  # circ_to_gene[, rowId := .I]
  # circ_to_gene[, label := label.backsplice(c(circ_start, circ_end), 
  #                                          c(exon_start, exon_end), 
  #                                          c(gene_start, gene_end), 
  #                                          flank = 1),
  #              by = rowId]
  # circ_to_gene[, `:=` (rowId = NULL)]
  # 
  # ## keep order of labels the same of the order of genes
  # circ_to_genes <- circ_to_gene[, .(circ_id = paste0(chr, ":", circ_start, "-", circ_end, ":", strand), 
  #                                   gene_id, gene_name, label)][
  #                                     , .(label = refine_label(label)), by = .(circ_id, gene_id, gene_name)][
  #                                       , .(gene_ids = paste0(unique(gene_id), collapse = "|"),
  #                                           gene_names = paste0(unique(gene_name), collapse = "|"),
  #                                           label = paste0(unique(label), collapse = "|")), 
  #                                       by = circ_id]
  circ_to_gene <- combined_gtf[, .(features = paste(unique(V12), collapse = ",")), 
                                by = .(circ_id, gene_id, gene_name)]
  circ_to_genes <- circ_to_gene[, .(label = paste0(features, collapse = "|"),
                                     gene_ids = paste0(gene_id, collapse = "|"),
                                     gene_names = paste0(gene_name, collapse = "|")), 
                                 by = .(circ_id)]
}

if(exists_circrnas & exists_gene_overlaps){
  setkey(circrna.rpms, gene_id)
  setkey(circ_to_genes, circ_id)
  circrna.rpms.genes <- circ_to_genes[circrna.rpms]
  
  ## split results per sample
  ## NB: use split function from data.table >= 1.9.7
  circrnas_expression.samples <- split(circrna.rpms.genes, by = "sample_id", keep.by = F, drop = T)
  
  ## save tables: one per sample
  save.sample.table <- function(sample, outdir){
    table.file <- file.path(outdir, paste0(sample, "_circrna_norm_expression.csv"))
    write.csv(x = circrnas_expression.samples[[sample]], file = table.file, row.names = F)
    table.file
  }
  
  sample.table.file.names <- sapply(X = names(circrnas_expression.samples), 
                                    FUN = save.sample.table, 
                                    outdir = results.dir)
}else{
  sample.table.file.names <- "No circRNAs detected"
}
```

Backsplices were detected using `r circrnas.gtf[, .N, by = V2][, .N]` programs in parallel: `r paste0(sort(circrnas.gtf[, .N, by = V2][, V2]), collapse = ", ")`

The detected circRNAs were saved in the following files:
```{r sample_circrna_table_files, echo=FALSE, include=TRUE}
sample.table.file.names <- as.data.frame(sample.table.file.names, stringsAsFactors = F)
sample.table.file.names$Sample <- rownames(sample.table.file.names)
sample.table.file.names <- sample.table.file.names[sort(rownames(sample.table.file.names)), ]
sample.table.file.names$basenames <-  sapply(sample.table.file.names$sample.table.file.names, 
                                                            basename)
sample.table.file.names$File <- sapply(sample.table.file.names$basenames, 
                                                            sub, pattern = "(.*)", 
                                                            replacement = '<a href="\\1">\\1</a>')

#kable(data.table(sample_id = names(sample.table.file.names), file = sample.table.file.names)[order(sample_id)])
kable(sample.table.file.names[, c("Sample", "File")], row.names = F, 
      caption = "Files in which the detected circRNAs were saved. One file per sample.")
```

```{r reliable_circrnas, echo=FALSE, include=TRUE}
############# CircRNA expression per sample ###########
## get the list of circRNAs detected by min_methods or more methods
circrnas.morethan2methods <- circrnas.gtf[, .N, 
                                          by = .(gene_id, V2)][
                                            , N := NULL][
                                              , .(n_methods = .N), 
                                              by = gene_id][
                                                n_methods >= min_methods, .(gene_id)]

## subset the circRNA expression table by the circRNAs detected by at least min_methods methods and
## with normalized median expression > 0
setkey(circrna.rpms.genes, circ_id)
setkey(circrnas.morethan2methods, gene_id)
circrnas.morethan2methods.medrpm <- circrna.rpms.genes[circrnas.morethan2methods][
  , .(circ_id, gene_ids, gene_names, label, sample_id, chr = V1, start = V4, end = V5, strand = V7, medRPM)][medRPM > 0]

circrnas.morethan2methods.medrpm.table <- circrnas.morethan2methods
if(nrow(circrnas.morethan2methods) > 0 ){
  ## reshape with one expression column per sample 
  circrnas.morethan2methods.medrpm.table <- data.table::dcast(data = circrnas.morethan2methods.medrpm, 
                                                              formula = circ_id + gene_ids + gene_names + label + chr + start + end + strand ~ sample_id,
                                                              value.var = "medRPM", fill = 0)
  
  # ## add a useful mean expression column
  # circrnas.morethan2methods.medrpm.table$avg_xpr <- apply(X = circrnas.morethan2methods.medrpm.table[
  #   , 9:ncol(circrnas.morethan2methods.medrpm.table)], 
  #   MARGIN = 1, FUN = mean)
}
## save table
circRNA_expression_per_sample.csv.basename <- "circRNA_expression_per_sample.csv"
write.csv(x = circrnas.morethan2methods.medrpm.table, 
          file = file.path(results.dir, circRNA_expression_per_sample.csv.basename), 
          row.names = F)

## the reference to the file is reported in the document section below

## TODO: save in HTML table with links
```

# Detected circRNA results
## CircRNAs detected per method

```{r show_circrnas_per_method, echo=FALSE, include=TRUE}

circ.per.method <- circrnas.gtf[V6 >= min_reads][, .N, by = .(gene_id, V2)]
#circ.per.method[, .N, by = V2][, Method := V2][order(-N), .(Method, N)]
non.redundant <- circ.per.method[, .N, by = gene_id][, .N]
## number of circRNAs per method
kable(rbind(circ.per.method[, .N, by = V2][, Method := V2][order(-N), .(Method, "Tot circRNAs" = N)], 
            list("Non-redundant", non.redundant)))

############# Barplot number of circRNAs per methods (sum over all samples) ###########
default.font.size <- 12
## select only circRNAs with >= 2 reads (not normalized values)
circByMethod.barplot <- ggplot(data = circ.per.method, mapping = aes(x = V2, fill = V2)) + 
  geom_bar(width = .7, colour="black") + 
  geom_text(stat='count', aes(label=..count..), vjust=-0.3, size=default.font.size*(5/14)) + 
  theme_bw() + xlab("CircRNA detection method") + ylab("CircRNA number") +
  ggtitle(bquote("CircRNAs detected with " >= .(min_reads) ~ "reads by each method"))

## compute limits to remove space from x-axis. Add a 10% increase to the top limit
circByMethod.barplot.limits <- c(0, max(circ.per.method[, .N, by = V2][, N])*1.1)
circByMethod.barplot + guides(fill=FALSE) + 
  theme(text = element_text(size=default.font.size), plot.title = element_text(hjust = 0.5)) + 
  scale_y_continuous(expand = c(0, 0), limits = circByMethod.barplot.limits) + 
  scale_fill_manual(values = rainbow(circ.per.method[, .N, by = V2][, .N])) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

### CircRNAs shared by methods

```{r show_circrnas_shared, echo=FALSE, include=TRUE}

############# Matrix of methods' shared circRNA counts ###########

shared.counts.table <- crossprod(x = table(circ.per.method[
  , `:=`(N = NULL, method = V2, V2 = NULL)]))
## save table
write.csv(x = data.frame(shared.counts.table), 
          file = file.path(results.dir, "methods_shared_circRNA_counts.csv"), 
          row.names = F)

kable(data.frame(shared.counts.table), caption = "")

############# Barplot number of circRNAs shared by methods ###########
## "\u2265" is the unicode character for 'greater than or equal'
sharedByMethod.barplot <- ggplot(data = circ.per.method[, .(shared_by = .N), by = gene_id], 
                                 mapping = aes(x = factor(shared_by), fill = factor(shared_by))) + 
  geom_bar(width = .7, color = "black") + 
  geom_text(stat='count', aes(label=..count..), vjust=-0.3, size=default.font.size*(5/14)) + 
  theme_bw() + xlab("Number of methods") + ylab("CircRNA number") +
  ggtitle(paste("Number of circRNAs (with \u2265", min_reads, "reads)\ncommonly detected by the methods"))
## compute limits to remove space from x-axis. Add a 10% increase to the top limit
sharedByMethod.barplot.limits <- c(0, max(circ.per.method[, .(shared_by = .N), by = gene_id][, .N, by=shared_by][, N])*1.1)
sharedByMethod.barplot + guides(fill=FALSE) + 
  theme(text = element_text(size=default.font.size), plot.title = element_text(hjust = 0.5)) + 
  scale_y_continuous(expand = c(0, 0), limits = sharedByMethod.barplot.limits) + 
  scale_fill_brewer(direction = 1)

```

```{r}
## save methods detecting each circRNA
cmet_per_circ.file <- file.path(results.dir, "cmet_per_circ.csv")

circ_met <- circrnas.gtf[V6 >= min_reads, 
             .(c_methods = paste0(sort(unique(V2)), collapse = "|"), 
               n_methods = length(unique(V2))),  
             by = .(sample_id, gene_id)] #[n_methods >= min_methods]

write.csv(circ_met[order(sample_id)], cmet_per_circ.file, row.names = F)
```

Methods detecting each circRNAs are listed in  <a href="`r basename(cmet_per_circ.file)`">`r basename(cmet_per_circ.file)`</a>.

```{r}
reduce.cmeth.names <- function(x){
    x <- gsub("circexplorer2", "ce2", x)
    x <- gsub("segemehl", "se", x)
    x <- gsub("tophat", "th", x)
    x
}

circ_met.to.plot <- circrnas.gtf[V6 >= min_reads, 
                                 .N, 
                                 by = .(gene_id, 
                                        V2)][, .(c_methods = paste0(sort(unique(reduce.cmeth.names(V2))), 
                                                                                    collapse = "|"), 
                                                                 n_methods = length(unique(V2))), by = gene_id]
circ_met.plot.height <- max(c(4, (circ_met.to.plot[, .N, by = c_methods][, .N]*0.5)/2.54))
```

```{r, fig.height=`circ_met.plot.height`}
ggplot(circ_met.to.plot, aes(x = c_methods)) + 
    geom_bar(stat = "count", position = "stack", color = "black", 
             aes(fill = factor(n_methods))) + 
    scale_fill_brewer(direction = 1) + 
    guides(fill=FALSE) + 
    geom_text(stat = 'count', aes(label = ..count..), hjust = -.05,
              size = default.font.size*(5/14)) + 
    scale_y_continuous(expand = c(0, 0)) + 
    coord_flip() + 
    facet_grid(facets = n_methods ~ ., scales = "free_y", space = "free") +
    geom_text(stat = 'count', aes(label = "", y = ..count.. * 1.1)) + 
    xlab("Method combinations") + ylab("CircRNAs") +
    ggtitle(paste("CircRNAs commonly\ndetected by the methods")) +
    theme_bw() + 
    theme(text = element_text(size = default.font.size), 
          plot.title = element_text(hjust = 0.5))

```


## CircRNAs detected in total

For each method, at least `r min_reads` reads were required to consider a circRNAs as detected. Further, circRNAs detected by at least `r min_methods` methods are considered more reliable.

With at least `r min_reads` reads | With at least `r min_reads` reads and `r min_methods` methods
---------------: | -----------------------------------------:
`r circrnas.gtf[RPM > 0, .N, by = .(gene_id)][, .N]` | `r circrnas.morethan2methods.medrpm.table[, .N]`

The reliable circRNAs have been saved in file <a href="`r circRNA_expression_per_sample.csv.basename`">`r circRNA_expression_per_sample.csv.basename`</a>. The fields of the table header are explained below:

|Field     |Description                                                                        |
|----------|---------------------------------------------------------------------------------- |
|circ_id   |the circRNA ID, composed as chromosome:start-end:strand (+/-)                      |
|gene_ids  |the circRNA-overlapping gene IDs, separated by a \| character                      |
|gene_names|the circRNA-overlapping gene symbols, separated by a \| character                  |
|label     |circRNA caracterization according to gene annotation, separated by a \| character *|
|chr       |circRNA chromosome                                                                 |
|start     |circRNA (backsplice) start position                                                |
|end       |circRNA (backsplice) end position                                                  |
|strand    |circRNA (backsplice) strand                                                        |
|sample_id |circRNA expression in the sample **                                                | 

\*  The order of the labels correnspond to the order of the overlapping genes. Labels are not repeated thogh, and the number of different label may be lower than the number of different genes.  
\*\* CircRNA expression is reported in reads per million mapped (RPM) computed as the median RPM of the circRNA detection methods used.  

```{r set custom color shades}
## set custom color shades
## function to compute color hues and colors to give to each sample
get.color.hues <- function(meta){
    intgroup.dt <- meta[, .(.N), by = .(sample_id, 
                                        condition)][order(sample_id), 
                                                    .(sample_id), by = condition]
    samples.per.condition <- data.frame(intgroup.dt[, .N, by = .(condition)], 
                                        row.names = "condition")
    n.conditions <- nrow(samples.per.condition)
    hues <- brewer_pal(palette = "Set2")(n.conditions)
    
    if(nrow(intgroup.dt) == 1){
        intgroup.dt[, `:=`(color = hues[1],  hue = hues[1])]
    }else{
        for(i in 1:n.conditions){
            n.hues <- samples.per.condition[i, "N"] + 2
            col.hues <- colorRampPalette(colors = c(hues[i], 
                                                    "white"))(n.hues)[1:(n.hues-2)]
            
            intgroup.dt[condition == rownames(samples.per.condition)[i], `:=`(color = col.hues,
                                                                              hue = hues[i])]
        }
    }
    intgroup.dt[]
}
```


```{r, echo=FALSE}
if(meta_file != ""){
    meta <- unique(fread(meta_file)[, .(sample_id = sample, condition)])
    intgroup.dt <- get.color.hues(meta)
}
```

## CircRNAs detected by sample

```{r show_circrnas_2reads_2methods_sample, echo=FALSE, include=TRUE}

circ.2reads.at.least <- circrnas.gtf[RPM > 0 , .N, 
                                     by = .(sample_id, gene_id)][, .(above_min_reads = .N), 
                                                                 by = sample_id]
colnames(circ.2reads.at.least)[colnames(circ.2reads.at.least) == "above_min_reads"] <- paste0("With at least ",
                                                                                              min_reads, " reads")

coln <- paste0("With at least ", min_reads, " reads and ", min_methods, " methods")
circ.2reads.at.least.2methods.at.least <- circrnas.morethan2methods.medrpm[, .N, 
                                                                           by = .(sample_id, circ_id)][
                                                                             , .(reliable = .N),
                                                                             by = sample_id]
colnames(circ.2reads.at.least.2methods.at.least)[colnames(circ.2reads.at.least.2methods.at.least) == "reliable"] <- coln
reliable.circ.tab <- merge(circ.2reads.at.least, circ.2reads.at.least.2methods.at.least, by = "sample_id")

#kable(reliable.circ.tab)
datatable(reliable.circ.tab, 
          rownames = F, 
          style = "bootstrap", class = "compact display", 
          caption = "", 
          fillContainer = F, autoHideNavigation = T, options = list(searching = F))
```

```{r plot_circrnas_2reads_2methods_sample, echo=FALSE, include=TRUE, fig.width=12}

reliable.circ.tab.long <- melt(data = reliable.circ.tab, id.vars = "sample_id", 
                               variable.name = "Filter", value.name = "count")
reliable.circ.tab.long.d <- merge(reliable.circ.tab.long, intgroup.dt, 
                                  by = "sample_id")[order(condition, sample_id)]
reliable.circ.tab.long.d$sample_id <- factor(reliable.circ.tab.long.d$sample_id, 
                                             levels =  unique(reliable.circ.tab.long.d$sample_id),
                                             ordered = T)

reliable.circ.barplot <- ggplot(data = reliable.circ.tab.long.d, 
                                mapping = aes(x = sample_id, y = count,
                                              fill = sample_id)) + 
  geom_bar(stat = "identity", width = .7, aes(colour = sample_id), position = "dodge") + 
  geom_text(stat='identity', aes(label= count), vjust=-0.3, size=default.font.size*(5/14)) +
  facet_wrap(facets = ~ Filter) + 
    ggtitle("CircRNAs per sample") + 
    xlab("") + 
    ylab("Number of circRNAs") + 
    theme_bw() + 
    theme(plot.title = element_text(hjust = 0.5))
## compute limits to remove space from x-axis. Add a 10% increase to the top limit
reliable.circ.barplot.limits <- c(0, max(reliable.circ.tab.long$count)*1.1)
reliable.circ.barplot <- reliable.circ.barplot + 
    guides(fill = FALSE, color = FALSE) +
    theme(text = element_text(size=default.font.size), 
        axis.text.x = element_text(angle=45, hjust=1)) + 
    scale_y_continuous(expand = c(0, 0), limits = reliable.circ.barplot.limits)

reliable.circ.barplot + 
    scale_fill_manual(values = setNames(intgroup.dt[, color], nm = intgroup.dt[, sample_id])) +
    scale_color_manual(values = setNames(intgroup.dt[, hue], nm = intgroup.dt[, sample_id]))

```

## Categories of detected circRNAs 

The following analysis regards the subset of `r circrnas.morethan2methods.medrpm.table[, .N]` detected with at least `r min_reads` reads and by at least `r min_methods` methods (__reliable circRNAs__). 

Considering the reliable circRNAs, the table below indicate the mumber of circRNAs falling in each annotation class according to backsplice start and end positions in relation to annotated exon or introns from overlapping genes.   
NB: circRNA backsplice positions may intersect exon/introns of several genes if multiple genes overlap.

```{r show circrnas categories tab, echo=FALSE, include=TRUE}
# circrnas.morethan2methods.medrpm$sorted_label <- sapply(circrnas.morethan2methods.medrpm$label, 
#                                                         function(x)paste0(sort(strsplit(x = x, 
#                                                                                         split = "|", 
#                                                                                         fixed = T)[[1]]), 
#                                                                           collapse = "|"))
circrnas.morethan2methods.medrpm$sorted_label <- circrnas.morethan2methods.medrpm$label

circrna.categories.tab <- circrnas.morethan2methods.medrpm[
    , .N, by = .(circ_id, sorted_label)][
        , .N, by = sorted_label][
            order(-N), .(Category = sorted_label, "All samples" = N)]

## by sample
if(nrow(circrnas.morethan2methods.medrpm) > 0){
    circrna.categories.tab.ext <- dcast(circrnas.morethan2methods.medrpm[
        , .N, by = .(circ_id, sorted_label, sample_id)][
            , .N, by = .(sorted_label, sample_id)], 
        formula = sorted_label ~ sample_id, value.var = "N", fill = 0)
    
    circrna.categories.tab.ext <- merge(circrna.categories.tab, 
                                        circrna.categories.tab.ext, 
                                        by.x = "Category", by.y = "sorted_label", all = T)
    ## by condition
    circrna.categories.cond.tab <- dcast(merge(circrnas.morethan2methods.medrpm[
        , .N, by = .(circ_id, sorted_label, sample_id)],
        intgroup.dt[, .(condition, sample_id)], by = "sample_id")[
            , .N, by = .(condition, sorted_label)], 
        formula = sorted_label ~ condition, value.var = "N", fill = 0)
    
    circrna.categories.tab.ext <- merge(circrna.categories.tab.ext, circrna.categories.cond.tab,
                                        by.x = "Category", by.y = "sorted_label", all = T)[order(-`All samples`),]
    
    ## TABLE of circRNA category counts
    datatable(data = circrna.categories.tab.ext,
              rownames = F, 
              style = "bootstrap", class = "compact display", 
              caption = "Number of circRNAs according to backsplice overlap with gene annotation", 
              fillContainer = F, autoHideNavigation = T, options = list(searching = F))
}else{
    print("No reliable circRNAs found :(")
}
```

In the following, circRNA categories are grouped into three main classes: _exonic_, _intronic_, and _intergenic_. We assigned the class _exonic_ when _exon_ appears in the category. For instance, _exon|intergenic_ class is grouped into _exonic_. If not _exonic_, the class is grouped into _intronic_ when _intron_ appears among the categories (and none _exon_): for instance, _intergenic|intron_ is grouped into _intronic_; _exon|intron_ is NOT grouped into _intronic_ since it is grouped into _exonic_. The _intergenic_ class groups only _intergenic_ categories.  

```{r show circrnas classes tab, echo=FALSE, include=TRUE}
circ.cat.cond.xpr <- merge(circrnas.morethan2methods.medrpm[
    , .(circ_id, medRPM, sample_id, sorted_label)], 
    intgroup.dt[, .(condition, sample_id)], by = "sample_id")

circ.cat.cond.xpr$simple_label <- sapply(circ.cat.cond.xpr$sorted_label, 
                                         simplify_circrna_labels)

## TABLE
## all samples together
circrna.classes.tab <- circ.cat.cond.xpr[
    , .N, by = .(circ_id, simple_label)][
        , .N, by = simple_label][
            order(-N), .(Class = simple_label, "All samples" = N)]

## by sample
circrna.classes.tab.ext <- dcast(circ.cat.cond.xpr[
    , .N, by = .(circ_id, simple_label, sample_id)][
        , .N, by = .(simple_label, sample_id)],
    formula = simple_label ~ sample_id, value.var = "N", fill = 0)

circrna.classes.tab.ext <- merge(circrna.classes.tab,
                                    circrna.classes.tab.ext,
                                    by.x = "Class", by.y = "simple_label", all = T)

## by condition
circrna.classes.cond.tab <- dcast(merge(circ.cat.cond.xpr[
    , .N, by = .(circ_id, simple_label, sample_id)],
    intgroup.dt[, .(condition, sample_id)], by = "sample_id")[
        , .N, by = .(condition, simple_label)],
    formula = simple_label ~ condition, value.var = "N", fill = 0)

circrna.categories.tab.ext <- merge(circrna.classes.tab.ext, circrna.classes.cond.tab,
                                    by.x = "Class", by.y = "simple_label", all = T)[order(-`All samples`),]

## TABLE of circRNA category counts
datatable(data = circrna.categories.tab.ext,
          rownames = F,
          style = "bootstrap", class = "compact display",
          caption = "Number of circRNAs according to backsplice overlap with gene annotation (classes)",
          fillContainer = F, autoHideNavigation = T, 
          options = list(searching = F, paging = F, info = F))

```

```{r show circrnas categories plots, echo=FALSE, include=TRUE}
## PLOTS
## boxplot of circRNA expression divided by circRNA category and , possibly, grouped by condition
## just group by category
circrna.cat.xpr.boxplot <- ggplot(data = circ.cat.cond.xpr, 
                                             mapping = aes(x = simple_label, y = medRPM, fill = simple_label)) + 
  geom_boxplot(notch = T) + scale_y_log10() + xlab(NULL) + ylab("RPM") + 
    scale_fill_discrete("Category") +
  ggtitle("CircRNAs' category\nexpression") + theme_bw()
circrna.cat.xpr.boxplot <- circrna.cat.xpr.boxplot + 
  theme(text = element_text(size=default.font.size), 
        #axis.text.x = element_text(angle=45, hjust=1), 
        plot.title = element_text(hjust = 0.5), 
        legend.position = "bottom")

## group by condition
circrna.cat.xpr.per.cond.boxplot <- ggplot(data = circ.cat.cond.xpr, 
                                             mapping = aes(x = condition, y = medRPM, fill = simple_label)) + 
  geom_boxplot(notch = T) + scale_y_log10() + xlab(NULL) + ylab("RPM") + 
    scale_fill_discrete("Category") +
  ggtitle("CircRNAs' category\nexpression") + theme_bw()
circrna.cat.xpr.per.cond.boxplot <- circrna.cat.xpr.per.cond.boxplot + 
  theme(text = element_text(size=default.font.size), 
        #axis.text.x = element_text(angle=45, hjust=1), 
        plot.title = element_text(hjust = 0.5), 
        legend.position = "bottom")

multiplot(circrna.cat.xpr.boxplot, circrna.cat.xpr.per.cond.boxplot, cols = 2)

## show all samples
circrna.cat.xpr.per.sample.boxplot <- ggplot(data = circ.cat.cond.xpr, 
                                             mapping = aes(x = sample_id, y = medRPM, fill = simple_label)) + 
  geom_boxplot(notch = T) + scale_y_log10() + 
    facet_grid(facets = . ~ condition, drop = T, scales = "free_x") + xlab(NULL) + ylab("RPM") + 
    scale_fill_discrete("Category") +
  ggtitle("CircRNAs' category\nexpression per sample") + theme_bw()
circrna.cat.xpr.per.sample.boxplot <- circrna.cat.xpr.per.sample.boxplot + 
  theme(text = element_text(size=default.font.size), 
        axis.text.x = element_text(angle=45, hjust=1), 
        plot.title = element_text(hjust = 0.5), 
        legend.position = "bottom")
circrna.cat.xpr.per.sample.boxplot

```

## CircRNAs expressed per gene

Only genes for which the circRNA has label _exonic_ or _intronic_ were considered. The _intergenic\_spanning\_gene_ circRNA-overlapping genes were not considered.

```{r circrnas_per_gene, echo=FALSE, include=TRUE}
## Number of circRNAs per gene
# this code does NOT count genes for which circRNA label is intergenic_spanning_gene!
# circRNAs.to.gene <- subset(circ_to_gene[, .(.N, label = paste0(unique(label), collapse = "|")), 
#                                          by = .(chr, circ_start, circ_end, strand, gene_id, gene_name)][
#                                              gene_id != ".", 
#                                              .(circ_id = paste0(chr, ":", circ_start,  "-", circ_end, ":", strand), 
#                                                gene_id, gene_name, label)], 
#                             circ_id %in% circrnas.morethan2methods.medrpm[
#                                 , .N ,by = circ_id][, circ_id])[label != "intergenic_spanning_gene"]
circRNAs.to.gene <- subset(circ_to_gene[gene_id != "."], 
                           circ_id %in% circrnas.morethan2methods.medrpm.table$circ_id)

## count circRNAs per gene and set the list of circRNAs of the gene
n.circ.per.gene <- circRNAs.to.gene[, .(n_circRNAs = .N, 
                                        circ_ids = paste0(unique(circ_id), collapse = "|")), 
                                    by = .(gene_id, gene_name)][order(-n_circRNAs)]

## save number of circRNAs per gene into a file
circRNAs_per_gene.file <- file.path(results.dir, "circRNAs_per_gene.csv")
write.csv(x = n.circ.per.gene, 
          file = circRNAs_per_gene.file, 
          row.names = F)


circRNAs.per.gene <- circRNAs.to.gene[, .(circRNAs_per_gene = .N),
                                      by = gene_id][order(-circRNAs_per_gene)]

```

Number of genes overlapping the `r circrnas.morethan2methods.medrpm.table[, .N]` reliable circRNAs: `r n.circ.per.gene[, .N]`

Number of circRNAs expressed by each gene, with the respective circRNAs IDs, are reported in file <a href="`r basename(circRNAs_per_gene.file)`">`r basename(circRNAs_per_gene.file)`</a> (only genes expressing circRNAs are reported).  

```{r intergenic spanning genes, echo=FALSE, include=TRUE}
# intergenic_spanning_gene_circrnas <- subset(circ_to_gene[, .(.N, label = paste0(unique(label), collapse = "|")), 
#                     by = .(chr, circ_start, circ_end, strand, gene_id, gene_name)][
#                         gene_id != ".", 
#                         .(circ_id = paste0(chr, ":", circ_start,  "-", circ_end, ":", strand), 
#                           gene_id, gene_name, label)], 
#        circ_id %in% circrnas.morethan2methods.medrpm[
#            , .N ,by = circ_id][, circ_id])[label == "intergenic_spanning_gene"]

# Genes that are spanned by circRNA backsplices are `r intergenic_spanning_gene_circrnas[, .N, by = gene_id][, .N]` and involve `r intergenic_spanning_gene_circrnas[, .N, by = circ_id][, .N]` circRNAs. Note that these circRNAs may be included in the count of circRNAs per gene when there are multiple genes annotated in the same locus.  

```


### Distribution of number of circRNAs per gene  

```{r plot_circrnas_per_gene, echo=FALSE, include=TRUE, fig.width=12}
## quartiles
kable(data.frame(Value = unclass(summary(circRNAs.per.gene$circRNAs_per_gene))))

## barplot
circRNAs.per.gene.plot <- ggplot(data = circRNAs.per.gene, mapping = aes(x = factor(circRNAs_per_gene))) + 
  geom_bar(stat = "count") + ggtitle("CircRNAs per gene") + xlab("Number of circRNAs") + ylab("Number of genes") + 
  theme_bw()
## compute limits to remove space from x-axis. Add a 10% increase to the top limit
circRNAs.per.gene.plot.limits <- c(0, max(circRNAs.per.gene[, .N, by=circRNAs_per_gene][, N])*1.1)
circRNAs.per.gene.plot <- circRNAs.per.gene.plot + 
  theme(text = element_text(size=default.font.size), axis.text.x = element_text(angle=90, hjust=1)) + 
  scale_y_continuous(expand = c(0, 0), limits = circRNAs.per.gene.plot.limits)
circRNAs.per.gene.plot + theme(plot.title = element_text(hjust = 0.5))

# # compute lower and upper whiskers
# ylim_circRNAs.per.gene = boxplot.stats(circRNAs.per.gene$circRNAs_per_gene)$stats[c(1, 5)]
# # scale y limits based on ylim1
# circRNAs.per.gene.boxplot <- ggplot(data = circRNAs.per.gene, mapping = aes(x = "", y = circRNAs_per_gene)) + 
#   geom_boxplot(notch = T, varwidth = T, width = 0.3) + coord_cartesian(ylim = ylim_circRNAs.per.gene*1.05) + xlab("") + 
#   ggtitle("CircRNAs per gene (outliers removed)") + theme_bw() + 
#   theme(text = element_text(size=default.font.size))
# 
# multiplot(circRNAs.per.gene.plot, circRNAs.per.gene.boxplot, cols = 2)
```

### Distribution of number of circRNAs per gene, for each sample

```{r plot_circrnas_per_gene_per_sample, echo=FALSE, include=TRUE, fig.width=12}
## Number of circRNA per gene, discriminating each sample
circRNAs.to.gene.per.sample <- merge(circrnas.morethan2methods.medrpm[, .(circ_id, sample_id)], 
                                      circRNAs.to.gene[, .(circ_id, gene_id, gene_name)], 
                                     by = "circ_id")

n.circ.per.gene.per.sample <- circRNAs.to.gene.per.sample[
    , .(n_circRNAs = .N, circ_ids = paste0(unique(circ_id), collapse = "|")), 
    by = .(sample_id, gene_id, gene_name)][order(sample_id, -n_circRNAs)]

## save circRNAs per gene per sample
circRNAs_per_gene.per.sample.file <- file.path(results.dir, "circRNAs_per_gene_per_sample.csv")
write.csv(x = n.circ.per.gene.per.sample,
          file = circRNAs_per_gene.per.sample.file,
          row.names = F)

circRNAs.per.gene.per.sample <- n.circ.per.gene.per.sample[, .(gene_id, gene_name, 
                                                               circRNAs_per_gene = n_circRNAs, 
                                                               sample_id)]

## quartiles (per sample)
kable(sapply(X = split(circRNAs.per.gene.per.sample, circRNAs.per.gene.per.sample$sample_id), 
             FUN = function(x){summary(x$circRNAs_per_gene)}), caption = "CircRNAs per gene distribution")


circRNAs.per.gene.per.sample$sample_id <- factor(circRNAs.per.gene.per.sample$sample_id, 
                                                 levels = meta[order(condition, sample_id), sample_id], 
                                                 ordered = T)

## barplot
circRNAs.per.gene.per.sample.plot <- ggplot(data = circRNAs.per.gene.per.sample, 
                                            mapping = aes(x = factor(circRNAs_per_gene),
                                                          fill = sample_id, 
                                                          color = sample_id)) + 
    geom_bar(stat = "count") + 
    facet_wrap(facets = ~ sample_id, scales = "free") + 
    ggtitle("CircRNAs per gene") + xlab("Number of circRNAs") + ylab("Number of genes") + 
    theme_bw()
circRNAs.per.gene.per.sample.plot <- circRNAs.per.gene.per.sample.plot + 
    theme(text = element_text(size=default.font.size), axis.text.x = element_text(angle=90, hjust=1))
if(gene_meta_file != ""){
    circRNAs.per.gene.per.sample.plot <- circRNAs.per.gene.per.sample.plot + 
        scale_fill_manual(values = setNames(intgroup.dt[, color], nm = intgroup.dt[, sample_id])) +
        scale_color_manual(values = setNames(intgroup.dt[, hue], nm = intgroup.dt[, sample_id]))
}
circRNAs.per.gene.per.sample.plot + 
    theme(plot.title = element_text(hjust = 0.5)) + 
    guides(fill = FALSE, color = FALSE)
```

Number of circRNAs expressed per gene, per each sample, have been saved in file <a href="`r basename(circRNAs_per_gene.per.sample.file)`">`r basename(circRNAs_per_gene.per.sample.file)`</a>. 

### Distribution of number of circRNAs per gene, grouped per condition

```{r plot_circrnas_per_gene_per_condition, echo=FALSE, include=TRUE, fig.width=12, fig.height=8}
circRNAs_per_gene.per.cond.file <- "Not applicable to this settings"
circRNAs.to.gene.per.sample <- merge(circRNAs.to.gene.per.sample, 
                                     intgroup.dt[, .(sample_id, condition)], 
                                     by = "sample_id")
if(intgroup.dt[, .N, by=condition][, .N] > 1){
    
    # combined_gtf <- merge(combined_gtf, intgroup.dt[, .(sample_id, condition)], by = "sample_id")
    ## 
    n.circ.per.gene.per.condition <- unique(circRNAs.to.gene.per.sample[, .(circ_id, 
                                                                            gene_id, 
                                                                            gene_name, 
                                                                            condition)])[, .(n_circRNAs = .N,            circ_ids = paste0(unique(circ_id), 
                              collapse = "|")), 
                              by = .(condition, gene_id, gene_name)][order(condition, -n_circRNAs)]
    
    circRNAs.per.gene.per.condition <- n.circ.per.gene.per.condition[, .(gene_id, gene_name, 
                                                                         circRNAs_per_gene = n_circRNAs,
                                                                         condition)]
    
    circRNAs_per_gene.per.cond.file <- file.path(results.dir, "circRNAs_per_gene_per_condition.csv")
    write.csv(x = n.circ.per.gene.per.condition,
              file = circRNAs_per_gene.per.cond.file,
              row.names = F)
    
    ## quartiles per condition TABLE
    kable(sapply(X = split(circRNAs.per.gene.per.condition, circRNAs.per.gene.per.condition$condition), 
                 FUN = function(x){summary(x$circRNAs_per_gene)}), 
          caption = "CircRNAs per gene distribution")
}
if(intgroup.dt[, .N, by=condition][, .N] > 1){
    ## barplot per condition
    circRNAs.per.gene.per.condition.plot <- ggplot(data = circRNAs.per.gene.per.condition, 
                                                   mapping = aes(x = factor(circRNAs_per_gene), 
                                                                 fill = condition)) + 
        geom_bar(stat = "count") + facet_wrap(facets = ~ condition, scales = "free", 
                                              nrow = intgroup.dt[, .N, by = condition][, .N]) + 
        ggtitle("CircRNAs per gene") + xlab("Number of circRNAs") + ylab("Number of genes") + 
        theme_bw() + scale_fill_manual(values = setNames(unique(intgroup.dt[, hue]), 
                                                         nm = unique(intgroup.dt[, condition])),
                                       guide = FALSE)
    circRNAs.per.gene.per.condition.plot <- circRNAs.per.gene.per.condition.plot + 
        theme(text = element_text(size=default.font.size), axis.text.x = element_text(angle=90, hjust=1))
    circRNAs.per.gene.per.condition.plot + 
        theme(plot.title = element_text(hjust = 0.5))
}
```

Number of circRNAs expressed per gene, grouping by condition, have been saved in file <a href="`r basename(circRNAs_per_gene.per.cond.file)`">`r basename(circRNAs_per_gene.per.cond.file)`</a>. 

## CircRNA expression vs number of circRNAs isoforms per gene

The following plots show circRNA expression distribution grouping per number of circRNAs expressed by gene. This is to analyze whether the expression of circRNAs changes if they are generated from genes expressing many circRNAs. In other words, whether the expression level of circRNAs is correlated to the number of circRNA isoforms expressed by a gene.  

Note: boxes are drawn with widths proportional to the square-roots of the number of observations in the groups

```{r CircRNA expression vs circRNAs expressed per gene, include=FALSE}
circ.expr.to.circ.per.gene.per.sample <- merge(circRNAs.to.gene.per.sample, 
                                               circrna.rpms[, .(circ_id = gene_id, 
                                                                sample_id, medRPM)], 
                                               by = c("circ_id", "sample_id"), 
                                               all.x = T, all.y = F)

## discriminate per sample
circ.expr.to.circ.per.gene.per.sample[, circRNAs_per_gene := .N, by = .(sample_id, gene_id)]
```

```{r CircRNA expression vs circRNAs expressed per gene plots, fig.width=12, fig.height=8}
## boxplot
circ.expr.to.circ.per.gene.per.sample.plot <- ggplot(data = circ.expr.to.circ.per.gene.per.sample, 
                                                     mapping = aes(x = factor(circRNAs_per_gene), y = medRPM)) + 
    geom_boxplot(varwidth = T, aes(fill = sample_id)) + 
    scale_y_log10() + facet_wrap(facets = ~ sample_id, scales = "free_x")
## add decorations to plot
circ.expr.to.circ.per.gene.per.sample.plot <- circ.expr.to.circ.per.gene.per.sample.plot + 
    ggtitle("CircRNAs per gene vs circRNA expression") + xlab("Number of circRNAs") + ylab("CircRNA RPM") + 
    theme_bw() + 
    theme(text = element_text(size=default.font.size), axis.text.x = element_text(angle=90, hjust=1))
if(gene_meta_file != ""){
    circ.expr.to.circ.per.gene.per.sample.plot <- circ.expr.to.circ.per.gene.per.sample.plot + 
        scale_fill_manual(values = setNames(intgroup.dt[, color], nm = intgroup.dt[, sample_id]))
}
circ.expr.to.circ.per.gene.per.sample.plot + theme(plot.title = element_text(hjust = 0.5)) + 
    guides(fill = FALSE)

## all samples together: mean expression across samples
circ.expr.to.circ.per.gene <- unique(circ.expr.to.circ.per.gene.per.sample[, .(avgRPM = mean(medRPM)), 
                                                                           by = .(gene_id, circ_id)])[
                                                                               , circRNAs_per_gene := .N, by = gene_id][]
circ.expr.to.circ.per.gene.plot <- ggplot(data = circ.expr.to.circ.per.gene, 
                                          mapping = aes(x = factor(circRNAs_per_gene), y = avgRPM)) + 
    geom_boxplot(varwidth = T) + scale_y_log10()
## add decorations to plot
circ.expr.to.circ.per.gene.plot <- circ.expr.to.circ.per.gene.plot + 
    ggtitle("CircRNAs per gene vs circRNA expression") + xlab("Number of circRNAs") + ylab("CircRNA RPM") + 
    theme_bw() + 
    theme(text = element_text(size=default.font.size), axis.text.x = element_text(angle=90, hjust=1))
circ.expr.to.circ.per.gene.plot + theme(plot.title = element_text(hjust = 0.5)) + 
    guides(fill = FALSE)

if(gene_meta_file != ""){
    ## discriminate per condition: mean expression across samples, within conditions
    circ.expr.to.circ.per.gene.per.condition <- unique(circ.expr.to.circ.per.gene.per.sample[, .(avgRPM = mean(medRPM)), 
                                                                                             by = .(condition, gene_id,
                                                                                                    circ_id)])[
                                                                                                 , circRNAs_per_gene := .N, 
                                                                                                 by = .(condition, gene_id)][]
    circ.expr.to.circ.per.gene.per.condition.plot <- ggplot(data = circ.expr.to.circ.per.gene.per.condition, 
                                                            mapping = aes(x = factor(circRNAs_per_gene), y = avgRPM,
                                                                          fill = condition)) + 
        geom_boxplot(varwidth = T) + scale_y_log10() +  
        facet_wrap(facets = ~ condition, scales = "free", nrow = intgroup.dt[, .N, by = condition][, .N])
    ## add decorations to plot
    circ.expr.to.circ.per.gene.per.condition.plot <- circ.expr.to.circ.per.gene.per.condition.plot + 
        ggtitle("CircRNAs per gene vs circRNA expression") + xlab("Number of circRNAs") + ylab("CircRNA RPM") + 
        theme_bw() + 
        theme(text = element_text(size=default.font.size), axis.text.x = element_text(angle=90, hjust=1))
    
    circ.expr.to.circ.per.gene.per.condition.plot <- circ.expr.to.circ.per.gene.per.condition.plot + 
        scale_fill_manual(values = setNames(unique(intgroup.dt[, hue]), 
                                            nm = unique(intgroup.dt[, condition])),
                          guide = FALSE)
    
    circ.expr.to.circ.per.gene.per.condition.plot + theme(plot.title = element_text(hjust = 0.5))
}
```

# CircRNA and gene expression

CircRNA expression by sample have been saved in file <a href="`r circRNA_expression_per_sample.csv.basename`">`r circRNA_expression_per_sample.csv.basename`</a>

## Expression of circRNA-overlapping genes

```{r show_gene_expressed_by_sample}
# get gene expressions
# setkey(circ_to_gene, features)
circrna_genes <- unique(circ_to_gene[features != "intergenic" &
                                         circ_id %in% circrnas.morethan2methods.medrpm.table$circ_id, 
                                     .(circ_id, 
                                       gene_id, 
                                       gene_name)])

if(file.info(gene_fpkm_file)$size > 0){
    # if(gene_meta_file != ""){
    #     gene_meta <- fread(gene_meta_file)
    #     gene_meta[, sample_id := sub("cuffquant/(.*)_hisat2.*", "\\1", file)]
    #     
    #     gene_fpkm <- as.data.table(read.table(file = gene_fpkm_file, header = T, sep = "\t", dec = ".", 
    #                                           colClasses = c("character", "factor", "numeric", 
    #                                                          "numeric", "numeric", "numeric", 
    #                                                          "numeric", "character", "character")))
    #     expressed_genes <- gene_fpkm[, FPKM := round(FPKM, digits = 8)]#[FPKM > 0]
    #     setkey(gene_meta, condition, replicate_num)
    #     setkey(expressed_genes, condition, replicate)
    #     expressed_genes <- expressed_genes[gene_meta[, .(sample_id, condition, replicate_num)]]
    # }else{
    #     gene_fpkm <- fread(gene_fpkm_file)
    #     expressed_genes <- gene_fpkm[, FPKM := round(FPKM, digits = 8)]#[FPKM > 0]
    #     expressed_genes$sample_id <- unique(circrnas.gtf$sample_id)
    # }
    gene_fpkm <- melt(fread(gene_fpkm_file), id.vars = "gene", 
                      variable.name = "sample", value.name = "FPKM")
    expressed_genes <- gene_fpkm[, `:=`(FPKM = round(FPKM, digits = 8), 
                                        tracking_id = gene, sample_id = sample)][]#[FPKM > 0]
    
    ## select only genes expressing circRNAs, keep also not expressed (FPKM==0) genes
    ## N.B: consider only genes for which a RELIABLE circRNA is expressed
    setkey(circrna_genes, gene_id)
    setkey(expressed_genes, tracking_id)
    expressed_genes <- subset(expressed_genes, tracking_id %in% unique(circrna_genes$gene_id))
    
    # ## now remove not expressed (FPKM == 0) genes for reporting
    # expressed_genes.by.sample <- expressed_genes[FPKM > 0, .N, 
    #                                              by = .(sample_id, tracking_id)][, .("Tot. gene expressed" = .N), 
    #                                                                              by = sample_id][order(sample_id),]
    # ## number of genes that express both linear and circular isoforms
    # tot.expressed.circrna.genes <- expressed_genes[FPKM > 0, .N, by = tracking_id][, .N]
    # 
    # ## summarize in a table, for each sample
    # kable(rbind(expressed_genes.by.sample, list("Non-redundant", tot.expressed.circrna.genes)), 
    #       caption = "For each sample, the number of genes expressed (FPKM > 0) that overlap a circRNA is reported")
    
    ################### 
    ## for each sample, the number of circRNA-overlapping genes 
    all.circrna.overlapping.genes <- merge(subset(circrna.rpms[, .(circ_id = gene_id, sample_id)], 
                                                  circ_id %in% circrnas.morethan2methods.medrpm.table$circ_id), 
                                           circ_to_gene[, .(circ_id, gene_id)], 
                                           by = "circ_id", all.x = T, all.y = F)
    
    number.of.circRNA.overlapping.genes.per.sample <- subset(all.circrna.overlapping.genes, 
                                                             gene_id %in% unique(expressed_genes$tracking_id))[
                                                                 , .N, by = .(sample_id, gene_id)][
                                                                     , .(`Number of circRNA-overlapping genes` = .N), 
                                                                     by = sample_id]
    tot.circrna.genes <- subset(all.circrna.overlapping.genes, 
                                gene_id %in% unique(expressed_genes$tracking_id))[
                                    , .N, by = .(gene_id)][, .N]
    
    # kable(number.of.circRNA.overlapping.genes.per.sample, row.names = F, 
    #       caption = "For each sample, the number of circRNA-overlapping genes is reported. Also genes NOT linearly expressed are considered")
    
    ## now remove not expressed (FPKM == 0) genes for reporting
    expressed_genes.by.sample <- subset(all.circrna.overlapping.genes, 
                                        gene_id %in% unique(expressed_genes[FPKM > 0]$tracking_id))[
                                            , .N, by = .(sample_id, gene_id)][
                                                , .(`Number of expressed circRNA-overlapping genes` = .N), 
                                                by = sample_id]
    ## number of genes that express both linear and circular isoforms
    tot.expressed.circrna.genes <- subset(all.circrna.overlapping.genes, 
                                          gene_id %in% unique(expressed_genes[FPKM > 0]$tracking_id))[
                                              , .N, by = .(gene_id)][, .N]
    
    ## summarize in a table, for each sample
    datatable(data = merge(rbind(number.of.circRNA.overlapping.genes.per.sample, 
                                 list("Non-redundant", tot.circrna.genes)), 
                           rbind(expressed_genes.by.sample, 
                                 list("Non-redundant", tot.expressed.circrna.genes)), 
                           by = "sample_id")[order(sample_id)],
              rownames = F, 
              style = "bootstrap", class = "compact display", 
              fillContainer = F, autoHideNavigation = T, options = list(searching = F),
              caption = "For each sample, the number of circRNA-overlapping genes and the number of circRNA-overlapping genes that are also linearly expressed (FPKM > 0) are reported.")
}else{
    tot.expressed.circrna.genes <- NA
    "Linear gene expression analysis not enabled"
}
```

There were `r circRNAs.per.gene[, .N]` - `r tot.expressed.circrna.genes` = `r circRNAs.per.gene[, .N] - tot.expressed.circrna.genes` genes that express only circular RNA isoforms.

```{r plot_gene_expressed_by_sample, fig.width=12}
## plot circRNA-overlapping gene (COG) count in each sample
if(file.info(gene_fpkm_file)$size > 0){
    number.of.circRNA.overlapping.genes.per.sample$sample_id <- factor(number.of.circRNA.overlapping.genes.per.sample$sample_id,
                                                                       levels = meta[order(condition, sample_id), sample_id],
                                                                       ordered = T)
    cog.by.sample.barplot <- ggplot(data = number.of.circRNA.overlapping.genes.per.sample, 
                                    mapping = aes(x = sample_id, y = `Number of circRNA-overlapping genes`,
                                                  fill = sample_id,
                                                  color = sample_id)) + 
        geom_bar(stat = "identity", width = .7) + 
        geom_text(stat='identity', aes(label = `Number of circRNA-overlapping genes`), 
                  vjust=-0.3, size=default.font.size*(5/14), color = "black") +
        ggtitle("CircRNA-overlapping gene counts") + xlab("") + ylab("Number of genes") + 
        theme_bw()
    ## compute limits to remove space from x-axis. Add a 10% increase to the top limit
    cog.by.sample.barplot.limits <- c(0, max(expressed_genes.by.sample$`Number of expressed circRNA-overlapping genes`)*1.1)
    cog.by.sample.barplot <- cog.by.sample.barplot + 
        guides(fill = FALSE, color = FALSE) +
        theme(text = element_text(size=default.font.size), axis.text.x = element_text(angle=45, hjust=1)) + 
        scale_y_continuous(expand = c(0, 0), limits = cog.by.sample.barplot.limits) + 
        theme(plot.title = element_text(hjust = 0.5))
    
    if(gene_meta_file != ""){
        cog.by.sample.barplot <- cog.by.sample.barplot + 
            scale_fill_manual(values = setNames(intgroup.dt[, color], nm = intgroup.dt[, sample_id])) + 
            scale_color_manual(values = setNames(intgroup.dt[, hue], nm = intgroup.dt[, sample_id]))
    }

    expressed_genes.by.sample$sample_id <- factor(expressed_genes.by.sample$sample_id,
                                                  levels = meta[order(condition, sample_id), sample_id],
                                                  ordered = T)
    expressed_genes.by.sample.plot <- ggplot(data = expressed_genes.by.sample, 
                                             mapping = aes(x = sample_id, y = `Number of expressed circRNA-overlapping genes`,
                                                           fill = sample_id,
                                                           color = sample_id)) + 
        geom_bar(stat = "identity", width = .7) + 
        geom_text(stat='identity', aes(label = `Number of expressed circRNA-overlapping genes`), 
                  vjust=-0.3, size=default.font.size*(5/14), color = "black") +
        ggtitle("Gene expressed (i.e. FPKM > 0) that overlap circRNAs") + xlab("") + ylab("Number of genes") + 
        theme_bw()
    ## compute limits to remove space from x-axis. Add a 10% increase to the top limit
    expressed_genes.by.sample.plot.limits <- c(0, max(expressed_genes.by.sample$`Number of expressed circRNA-overlapping genes`)*1.1)
    expressed_genes.by.sample.plot <- expressed_genes.by.sample.plot + 
        guides(fill = FALSE, color = FALSE) +
        theme(text = element_text(size=default.font.size), axis.text.x = element_text(angle=45, hjust=1)) + 
        scale_y_continuous(expand = c(0, 0), limits = expressed_genes.by.sample.plot.limits) + 
        theme(plot.title = element_text(hjust = 0.5))
    
    if(gene_meta_file != ""){
        expressed_genes.by.sample.plot <- expressed_genes.by.sample.plot + 
            scale_fill_manual(values = setNames(intgroup.dt[, color], nm = intgroup.dt[, sample_id])) +
            scale_color_manual(values = setNames(intgroup.dt[, hue], nm = intgroup.dt[, sample_id]))
    }
    
    multiplot(cog.by.sample.barplot, expressed_genes.by.sample.plot, cols = 2)
}else{
    "Linear gene expression analysis not enabled" 
}
```

## Expression distribution of circRNA-overlapping genes, per each sample

```{r show_gene_expression}
if(file.info(gene_fpkm_file)$size > 0){
    kable(sapply(X = split(expressed_genes, expressed_genes$sample_id), 
                 FUN = function(x){summary(x$FPKM)}), caption = "Gene expression (FPKM) distribution of circRNA-overlapping genes, including linearly not-expressed genes")
    
    kable(sapply(X = split(expressed_genes[FPKM > 0], expressed_genes[FPKM > 0]$sample_id), 
                 FUN = function(x){summary(x$FPKM)}), caption = "Gene expression (FPKM) distribution of circRNA-overlapping genes: only expressed genes")
}else{
    "Linear gene expression analysis not enabled" 
}
```

## CircRNA expression distribution by sample

```{r show_reliable_circrnas_expression, echo=FALSE, include=TRUE}
kable(sapply(X = split(circrnas.morethan2methods.medrpm, circrnas.morethan2methods.medrpm$sample_id), 
       FUN = function(x){summary(x$medRPM)}), caption = "CircRNA expression (RPM) distribution")
```

```{r plot_reliable_circrnas_expression, echo=FALSE, include=TRUE}
## boxplot expression per sample: circRNAs

# notch:	Notches are used to compare groups; if the notches of two boxes do not overlap, 
# this suggests that the medians are significantly different.
# varwidth: boxes are drawn with widths proportional to the square-roots of the number 
# of observations in the groups (possibly weighted, using the weight aesthetic).

circrnas.morethan2methods.medrpm$sample_id <- factor(circrnas.morethan2methods.medrpm$sample_id, 
                                                     levels = meta[order(condition, sample_id), sample_id], 
                                                     ordered = T)
circrna.xpr.per.sample.boxplot <- ggplot(data = circrnas.morethan2methods.medrpm, 
                                         mapping = aes(x = sample_id, y = medRPM, fill = sample_id)) + 
  geom_boxplot(notch = T, varwidth = T) + scale_y_log10() + xlab(NULL) + ylab("RPM") + #labels = scales::comma
  ggtitle("CircRNA expression\nper sample") + theme_bw()
circrna.xpr.per.sample.boxplot <- circrna.xpr.per.sample.boxplot + guides(fill=FALSE) + 
  theme(text = element_text(size=default.font.size), axis.text.x = element_text(angle=45, hjust=1)) + 
        theme(plot.title = element_text(hjust = 0.5))
#circrna.xpr.per.sample.boxplot ## this is diplayed later below!
```

## CircRNA and circRNA-overlapping gene expression plots

In this section only the `r ifelse(file.info(gene_fpkm_file)$size > 0, expressed_genes[FPKM > 0, .N, by = tracking_id][, .N], NA)` expressed circRNA-overlapping genes are considered

### Expression distribution of circRNAs and of genes overlapping circRNAs

Notes on boxplot decorations:  

- notches are used to compare groups; if the notches of two boxes do not overlap, this suggests that the medians are significantly different.  
- boxes are drawn with widths proportional to the square-roots of the number of observations in the groups  

```{r plot_gene_expression}
if(file.info(gene_fpkm_file)$size > 0){
    ## boxplot expression per sample: genes
    expressed_genes$sample_id <- factor(expressed_genes$sample_id, 
                                                     levels = meta[order(condition, sample_id), sample_id], ordered = T)
    gene.xpr.per.sample.boxplot <- ggplot(data = expressed_genes[FPKM > 0], 
                                          mapping = aes(x = sample_id, y = FPKM, fill = sample_id)) + 
        geom_boxplot(notch = T, varwidth = T) + scale_y_log10() + xlab(NULL) + ylab("FPKM") + #labels = scales::comma
        ggtitle("Expressed circRNA-overlapping gene expression\nper sample") + theme_bw()
    
    gene.xpr.per.sample.boxplot <- gene.xpr.per.sample.boxplot + guides(fill=FALSE) + 
        theme(text = element_text(size=default.font.size), axis.text.x = element_text(angle=45, hjust=1)) + 
        theme(plot.title = element_text(hjust = 0.5))
}
```


```{r plot_circ_gene_expr, fig.width=12, fig.height=4}
circrna.xpr.per.sample.boxplot <- circrna.xpr.per.sample.boxplot + 
    scale_fill_manual(values = setNames(intgroup.dt[, color], nm = intgroup.dt[, sample_id]))
if(gene_meta_file != ""){
    if(file.info(gene_fpkm_file)$size > 0){
        gene.xpr.per.sample.boxplot <- gene.xpr.per.sample.boxplot + 
            scale_fill_manual(values = setNames(intgroup.dt[, color], nm = intgroup.dt[, sample_id]))
        multiplot(circrna.xpr.per.sample.boxplot, gene.xpr.per.sample.boxplot, cols = 2)
    }else{
        circrna.xpr.per.sample.boxplot
    }
}else{
    circrna.xpr.per.sample.boxplot
}
```

### Cumulative expression

```{r cumulative_expression, include=FALSE}
## cumulative expression of circRNAs
cum_by_sample <- circrnas.morethan2methods.medrpm[order(sample_id, -medRPM), 
                                                  .(csum = cumsum(medRPM), seqid = seq_along(.I), circ_id), 
                                                  by = .(sample_id)]
cum_by_sample[, cond_tot := max(csum), by = .(sample_id)][, perc_csum := csum/cond_tot]

# if(gene_meta_file != ""){
#     cum_by_sample <- merge(cum_by_sample, intgroup.dt[, .(sample_id, condition)], by = "sample_id")
# }else{
#     cum_by_sample$condition <- "unset"
# }
cum_by_sample <- merge(cum_by_sample, intgroup.dt[, .(sample_id, condition)], by = "sample_id")

if(file.info(gene_fpkm_file)$size > 0){
    ## cumulative expression of expressed circRNA-overlapping genes
    cum_gene_by_sample <- expressed_genes[FPKM > 0][order(sample_id, -FPKM), 
                                                    .(csum = cumsum(FPKM), seqid = seq_along(.I), tracking_id), 
                                                    by = .(sample_id)]
    cum_gene_by_sample[, cond_tot := max(csum), by = .(sample_id)][, perc_csum := csum/cond_tot]
    
    if(gene_meta_file != ""){
        cum_gene_by_sample <- merge(cum_gene_by_sample, intgroup.dt[, .(sample_id, condition)], by = "sample_id")
    }else{
        cum_gene_by_sample$condition <- "unset"
    }
}
```

```{r cumulative_expression_box, fig.width=12, fig.height=6}
## Cumulative expression plot: circRNAs
circrna.cumsum.per.sample <- ggplot(data = cum_by_sample, mapping = aes(x = seqid, y = perc_csum, 
                                                                        color = sample_id, linetype = condition)) +
    geom_line() + ggtitle("Cumulative circRNA expression") + xlab("Number of circRNAs") +
    ylab("Cumulative expression") + scale_y_continuous(labels = scales::percent) + 
    theme_bw()
circrna.cumsum.per.sample <- circrna.cumsum.per.sample +
    theme(text = element_text(size=default.font.size), legend.position = "bottom") + 
    theme(plot.title = element_text(hjust = 0.5))
circrna.cumsum.per.sample <- circrna.cumsum.per.sample + 
    scale_color_manual(values = setNames(intgroup.dt[, color], nm = intgroup.dt[, sample_id]), "Sample") + 
    guides(color = guide_legend(ncol = intgroup.dt[, .N, by = condition][, .N]), 
           linetype = guide_legend(direction = "vertical"))

if(file.info(gene_fpkm_file)$size > 0){
    ## Cumulative expression plot: genes
    gene.cumsum.per.sample <- ggplot(data = cum_gene_by_sample, mapping = aes(x = seqid, y = perc_csum, 
                                                                              color = sample_id, linetype = condition)) +
        geom_line() + ggtitle("Cumulative circRNA-overlapping gene expression") + xlab("Number of genes") +
        ylab("Cumulative expression") + scale_y_continuous(labels = scales::percent) +
        theme_bw()
    gene.cumsum.per.sample <- gene.cumsum.per.sample +
        theme(text = element_text(size=default.font.size), legend.position = "bottom") + 
        theme(plot.title = element_text(hjust = 0.5))
    
    if(gene_meta_file != ""){
        gene.cumsum.per.sample <- gene.cumsum.per.sample + 
            scale_color_manual(values = setNames(intgroup.dt[, color], nm = intgroup.dt[, sample_id]), "Sample") + 
            guides(color = guide_legend(ncol = intgroup.dt[, .N, by = condition][, .N]), 
                   linetype = guide_legend(direction = "vertical"))
    }else{
        gene.cumsum.per.sample <- gene.cumsum.per.sample + scale_color_discrete("Sample")
    }
    multiplot(circrna.cumsum.per.sample, gene.cumsum.per.sample, cols=2)
}else{
    circrna.cumsum.per.sample
}
```

## Correlation of circRNA and circRNA-overlapping gene expression 

```{r correlation, echo=FALSE, include=FALSE}
#median circRNA expression (circrna detected by at least 2 methods)
circ_xpr_by_sample <- circrna.rpms.genes[circrnas.morethan2methods][
    medRPM > 0, .(medRPM), by = .(circ_id, sample_id)]
# expand the table to include all samples; assume 0 expression for circRNA not detected in samples
circ_xpr_all_sample <- merge(circ_xpr_by_sample, 
                             CJ(circ_id = unique(circ_xpr_by_sample[, circ_id]), 
                                sample_id = unique(circ_xpr_by_sample[, sample_id])), 
                             all = T, by = c("circ_id", "sample_id"))
circ_xpr_all_sample$medRPM[is.na(circ_xpr_all_sample$medRPM)] <- 0.0

# select only circRNAs that are overlapping a gene
# attach circRNA expression
genic_circrnas <- merge(circrna_genes, circ_xpr_all_sample, 
                        all.x = T, all.y = F, by = "circ_id",
                        allow.cartesian = T)[!is.na(medRPM)]

if(file.info(gene_fpkm_file)$size > 0){    
    
    # avg gene expression
    gene_xpr_by_sample <- expressed_genes[, .(gene_id = tracking_id, sample_id, FPKM)]
    # expand the table to include all samples; assume 0 expression for gene not detected in samples
    gene_xpr_all_sample <- merge(gene_xpr_by_sample, 
                                 CJ(gene_id = unique(gene_xpr_by_sample[, gene_id]), 
                                    sample_id = unique(gene_xpr_by_sample[, sample_id])), 
                                 all = T, by = c("gene_id", "sample_id"))
    gene_xpr_all_sample$FPKM[is.na(gene_xpr_all_sample$FPKM)] <- 0.0
    
    # get expression of genes for which a circRNA has been detected in at least one sample
    # setkey(gene_xpr_all_sample, gene_id)
    # circrna_gene_xpr <- gene_xpr_all_sample[genic_circrnas[, .(n_samples = .N), by = .(gene_id)][, .(gene_id)]]
    # 
    # genic_circrnas <- merge(genic_circrnas, circrna_gene_xpr, all.x = T, all.y = F, by = c("gene_id", "sample_id"))
    
    setkey(gene_xpr_all_sample, gene_id, sample_id)
    setkey(genic_circrnas, gene_id, sample_id)
    genic_circrnas <- gene_xpr_all_sample[genic_circrnas][is.na(FPKM), FPKM := 0]
    
    # compute coorelations (matrix?)
    genic_circrnas_corr <- genic_circrnas[, .(corr = cor(medRPM, FPKM, method = "spearman")), 
                                          by = .(circ_id, gene_id)]
    
    # circrna_gene_xpr_bysample_corr <- genic_circrnas
    # if(nrow(genic_circrnas) > 0){
    #   # put correlations in tabular format
    #   circrna_gene_xpr_bysample <- dcast(genic_circrnas, 
    #                                      formula = circ_id + gene_id + gene_name ~ sample_id, 
    #                                      value.var = c("FPKM", "medRPM"), 
    #                                      fill = 0)
    #   circrna_gene_xpr_bysample_corr <- merge(circrna_gene_xpr_bysample, genic_circrnas_corr, by = c("circ_id", "gene_id"))
    # }
    # #save table
    # circRNA_gene_expression_correlation.csv.basename <- "circRNA_gene_expression_correlation.csv"
    # write.csv(x = circrna_gene_xpr_bysample_corr, 
    #           file = file.path(results.dir, circRNA_gene_expression_correlation.csv.basename), 
    #           row.names = F)
    
    ## attach circRNA labels
    # genic_circrnas_corr.w.labels <- merge(genic_circrnas_corr, 
    #                                       circrna.rpms.genes[, .N, by = .(circ_id, label)][
    #                                           circrnas.morethan2methods.medrpm.table[, .(circ_id)]][
    #                                               , N:=NULL][], 
    #                                       by = "circ_id", all.x = T, all.y = F)
    
    # genic_circrnas_corr.w.labels <- merge(genic_circrnas_corr, 
    #                                       unique(circ_to_gene[
    #                                           , .(circ_id = paste0(chr, ":", 
    #                                                                circ_start, "-", 
    #                                                                circ_end, ":", strand), 
    #                                               gene_id, label)][
    #                                                   , .(label = refine_label(label)), 
    #                                                   by = .(circ_id, gene_id)])[
    #                                                       paste0(circ_id, gene_id) %in% genic_circrnas_corr[, .(cg = paste0(circ_id, gene_id))]$cg], 
    #                                       by = c("circ_id", "gene_id"), all.x = T, all.y = F)
    # genic_circrnas_corr.w.labels[, simple_label := label]
    genic_circrnas_corr.w.labels <- merge(genic_circrnas_corr, 
                                          circ_to_gene, 
                                          by = c("circ_id", "gene_id"), 
                                          all.x = T, all.y = F)
    genic_circrnas_corr.w.labels$simple_label <- sapply(genic_circrnas_corr.w.labels$features,
                                                        simplify_circrna_labels)
    # genic_circrnas_corr.w.labels$simple_label <- sapply(genic_circrnas_corr.w.labels$label, simplify_circrna_labels)
    
    ## attach expression values
    circrna_gene_xpr_bysample_corr <- genic_circrnas
    if(nrow(genic_circrnas) > 0){
        # put correlations in tabular format
        circrna_gene_xpr_bysample <- dcast(genic_circrnas, 
                                           formula = circ_id + gene_id + gene_name ~ sample_id, 
                                           value.var = c("FPKM", "medRPM"), 
                                           fill = 0)
        circrna_gene_xpr_bysample_corr <- merge(circrna_gene_xpr_bysample, 
                                                genic_circrnas_corr.w.labels, 
                                                by = c("circ_id", "gene_id"))
    }
    #save table
    circRNA_gene_expression_correlation.csv.basename <- "circRNA_gene_expression_correlation.csv"
    write.csv(x = circrna_gene_xpr_bysample_corr, 
              file = file.path(results.dir, circRNA_gene_expression_correlation.csv.basename), 
              row.names = F)
}else{
    circrna_gene_xpr_bysample_corr <- data.table(mock = numeric())
    circRNA_gene_expression_correlation.csv.basename <- NA
}
```

Correlations were computed considering exonic or intronic circRNAs (i.e. excluding intergenic circRNAs), and circRNA-overlapping genes including not expressed ones.  


|                              Expressed circRNAs|                  Exonic or intronic circRNAs|
|-----------------------------------------------:| -------------------------------------------:|
|`r circ_xpr_by_sample[, .N, by = circ_id][, .N]`| `r genic_circrnas[, .N, by = circ_id][, .N]`|

In total, `r ifelse(nrow(circrna_gene_xpr_bysample_corr) > 0, circrna_gene_xpr_bysample_corr[! is.na(corr)][, .N], 0)` correlations were computed involving `r ifelse(nrow(circrna_gene_xpr_bysample_corr) > 0, circrna_gene_xpr_bysample_corr[! is.na(corr)][, .N, by = circ_id][, .N], 0)` circRNAs and 
`r ifelse(nrow(circrna_gene_xpr_bysample_corr) > 0, circrna_gene_xpr_bysample_corr[! is.na(corr)][, .N, by = gene_id][, .N], 0)` genes. It can happen that correlation computation failed for some gene/circRNA because of null expression in too many samples.   

Correlation values were saved in file <a href="`r circRNA_gene_expression_correlation.csv.basename`">`r circRNA_gene_expression_correlation.csv.basename`</a>.

The following barplot rounded correlation values to the first decimal place.

```{r corr bar plot, fig.height=4, fig.width=8}
if(file.info(gene_fpkm_file)$size > 0){
    corr.bar.plot <- ggplot(data = genic_circrnas_corr.w.labels, 
                            mapping = aes(x = round(corr, 1), fill = simple_label)) + geom_bar()
    corr.bar.plot <- corr.bar.plot + theme_bw() +
        xlab("Spearman correlation") + ylab("Count") + scale_fill_discrete("CircRNA category") + 
        ggtitle("CircRNA-gene expression correlation distribution") 
    corr.bar.plot.limits <- c(0, max(genic_circrnas_corr.w.labels[, .N, by = round(corr, 1)][, N])*1.1)
    corr.bar.plot + theme(text = element_text(size=default.font.size), 
                          plot.title = element_text(hjust = 0.5), legend.position = "bottom") + 
        scale_y_continuous(expand = c(0, 0), limits = corr.bar.plot.limits)
    
    ## barplot detailed per circRNA category
    corr.cat.bar.plot <- ggplot(data = genic_circrnas_corr.w.labels, 
                                mapping = aes(x = round(corr, 1), fill = simple_label)) + 
        geom_bar() + facet_grid(facets = simple_label ~ ., scales = "free") + 
        theme_bw() + ggtitle("CircRNA-gene expression correlation distribution") +
        xlab("Spearman correlation") + ylab("Count") + scale_fill_discrete("CircRNA category") +
        theme(text = element_text(size=default.font.size), 
              plot.title = element_text(hjust = 0.5), 
              legend.position = "bottom")
    corr.cat.bar.plot
    
    corr.summaries <- rbind(as.data.table(data.frame("Spearman correlation" = unclass(summary(circrna_gene_xpr_bysample_corr$corr)), 
                                                     cat = "Total"), keep.rownames = T),
                            as.data.table(data.frame("Spearman correlation" = unclass(summary(circrna_gene_xpr_bysample_corr[corr >= 0]$corr)), 
                                                     cat = "Only positive"), keep.rownames = T),
                            as.data.table(data.frame("Spearman correlation" = unclass(summary(circrna_gene_xpr_bysample_corr[corr < 0]$corr)), 
                                                     cat = "Only negative"), keep.rownames = T))
    
    kable(dcast(corr.summaries, formula = rn ~ cat, value.var = "Spearman.correlation"),
          caption = "Correlations distribution")
}
```

```{r correlations_box, fig.width=12, fig.height=4}
if(file.info(gene_fpkm_file)$size > 0){
    cor.boxplot <- ggplot(data = circrna_gene_xpr_bysample_corr) + 
        geom_boxplot(aes(x = "", y = corr), notch = T, width = .5) + 
        theme_bw() + xlab("") + 
        ylab("Correlation") + ggtitle("Correlation\ndistribution") + 
        theme(plot.title = element_text(hjust = 0.5))
    
    non.na.cors <- circrna_gene_xpr_bysample_corr[
        , .(pos_corr = ifelse(corr > 0, "Positive", "Negative"), corr)][!is.na(corr)]
    if(length(non.na.cors$pos_corr) == 0){
        non.na.cors <- as.data.table(list(pos_corr = c("Positive", "Negative"), corr = c(NA, NA)))
    }
    cor.abs.boxplot <- ggplot(data = non.na.cors) +
        geom_boxplot(aes(x = "", y = abs(corr), fill = pos_corr), notch = T, varwidth = T)  +
        scale_fill_manual(values = c("blue", "red")) + facet_wrap(facets = ~ pos_corr) +
        theme_bw() + guides(fill = FALSE) + xlab("") + ylab("Abs(correlation)") +
        ggtitle("Absolute negative and positive\ncorrelation distributions") +
        theme(plot.title = element_text(hjust = 0.5))
    
    multiplot(cor.boxplot, cor.abs.boxplot, cols = 2)
    #make HTML version of corralation table
}
```

```{r correlation by condition}
if(file.info(gene_fpkm_file)$size > 0){
    if(intgroup.dt[, .N, by = condition][, .N] > 1 && all(intgroup.dt$samples_per_condition > 1)){
        cor.by.cond <- merge(genic_circrnas, 
                             intgroup.dt[, .(condition, sample_id)], 
                             by = "sample_id")[, .(corr = cor(medRPM, FPKM, method = "spearman")), 
                                               by = .(condition, circ_id, gene_id)]
        
        # cor.by.cond.w.labels <- merge(cor.by.cond,
        #                               circrna.rpms.genes[, .N, by = .(circ_id, label)][
        #                                   circrnas.morethan2methods.medrpm.table[, .(circ_id)]][
        #                                       , N:=NULL][], 
        #                               by = "circ_id", all.x = T, all.y = F)
        cor.by.cond.w.labels <- merge(cor.by.cond,
                                      genic_circrnas_corr.w.labels[, .(circ_id, gene_id, simple_label)], 
                                      by = c("circ_id", "gene_id"), all.x = T, all.y = F)
        
        #cor.by.cond.w.labels$simple_label <- sapply(cor.by.cond.w.labels$label, simplify_circrna_labels)
        
        ## number of non-NA correlations
        kable(cor.by.cond.w.labels[!is.na(corr), .N, by = .(condition)], 
              caption = "Number of correlations computed per condition")
    }
}
```

```{r correlation by condition summary table}
circRNA_gene_expression_correlation.cond.csv.basename <- "circRNA_gene_expression_correlation_by_condition.csv"
if(file.info(gene_fpkm_file)$size > 0){
    if(intgroup.dt[, .N, by = condition][, .N] > 1 && all(intgroup.dt$samples_per_condition > 1)){
        ## compute summaries by condition
        total.cond.corr <- as.data.table(data.frame("Total" = sapply(split(cor.by.cond.w.labels$corr, 
                                                                           f = cor.by.cond.w.labels$condition), 
                                                                     summary)), keep.rownames = T)
        positive.cond.cor <- 
            data.frame("Only positive" = 
                           sapply(split(cor.by.cond.w.labels[corr >= 0 ]$corr, 
                                        f = cor.by.cond.w.labels[corr >= 0 ]$condition),
                                  summary))
        if(nrow(positive.cond.cor) == 0){
            positive.cond.cor <- matrix(NA, nrow = 7, ncol = nrow(intgroup.dt[, .N, by = condition]))
            colnames(positive.cond.cor) <- as.character(unique(intgroup.dt$condition))
            rownames(positive.cond.cor) <- names(summary(cor.by.cond.w.labels$corr))
            positive.cond.cor <- data.frame("Only positive" = positive.cond.cor)
        }
        positive.cond.cor <- as.data.table(positive.cond.cor, keep.rownames = T)
        
        negative.cond.corr <- 
            data.frame("Only negative" = 
                           sapply(split(cor.by.cond.w.labels[corr < 0 ]$corr, 
                                        f = cor.by.cond.w.labels[corr < 0 ]$condition), 
                                  summary))
        if(nrow(negative.cond.corr) == 0){
            negative.cond.corr <- matrix(NA, nrow = 7, ncol = nrow(intgroup.dt[, .N, by = condition]))
            colnames(negative.cond.corr) <- as.character(unique(intgroup.dt$condition))
            rownames(negative.cond.corr) <- names(summary(cor.by.cond.w.labels$corr))
            negative.cond.corr <- data.frame("Only negative" = negative.cond.corr)
        }
        negative.cond.corr <- 
            as.data.table(negative.cond.corr, keep.rownames = T)
                
        corr.by.cond.summaries <- merge(merge(total.cond.corr, 
                                              positive.cond.cor, 
                                              by = "rn", all = T), 
                                        negative.cond.corr, by = "rn", all = T)
        
        kable(corr.by.cond.summaries, caption = "Correlations distribution grouping by condition")
    }
    
    
    if(intgroup.dt[, .N, by = condition][, .N] > 1 && all(intgroup.dt$samples_per_condition > 1)){
        if(nrow(cor.by.cond.w.labels) > 0){
            # put correlations in tabular format
            circrna_gene_xpr_by_cond_corr <- merge(circrna_gene_xpr_bysample, 
                                                   cor.by.cond.w.labels, 
                                                   by = c("circ_id", "gene_id"))[order(condition, 
                                                                                       -corr, circ_id, gene_id)]
        }
        #save table
        write.csv(x = circrna_gene_xpr_by_cond_corr, 
                  file = file.path(results.dir, circRNA_gene_expression_correlation.cond.csv.basename), 
                  row.names = F)
        
    }
}
```

When applicable, correlations per condition are saved in file <a href="`r circRNA_gene_expression_correlation.cond.csv.basename`">`r circRNA_gene_expression_correlation.cond.csv.basename`</a>

```{r correlation by condition bar plot, fig.height=4, fig.width=8}
if(file.info(gene_fpkm_file)$size > 0){
    if(intgroup.dt[, .N, by = condition][, .N] > 1 && all(intgroup.dt$samples_per_condition > 1)){
        
        corr.by.cond.bar.plot <- ggplot(data = cor.by.cond.w.labels, 
                                        mapping = aes(x = round(corr, 1), fill = simple_label)) + 
            geom_bar() + facet_wrap(facets = ~ condition, scales = "free_y", 
                                    nrow = intgroup.dt[, .N, by = condition][, .N])
        corr.by.cond.bar.plot <- corr.by.cond.bar.plot + theme_bw() +
            xlab("Spearman correlation") + ylab("Count") + 
            scale_fill_discrete("CircRNA category") +
            ggtitle("CircRNA-gene expression correlation distribution") 
        corr.by.cond.bar.plot + theme(text = element_text(size=default.font.size), 
                                      plot.title = element_text(hjust = 0.5), 
                                      legend.position = "bottom")
    }
}
```

```{r correlations box by condition, fig.width=12, fig.height=4}
if(file.info(gene_fpkm_file)$size > 0){
    if(intgroup.dt[, .N, by = condition][, .N] > 1 && all(intgroup.dt$samples_per_condition > 1)){
        
        cor.by.cond.boxplot <- ggplot(data = circrna_gene_xpr_by_cond_corr) + 
            geom_boxplot(aes(x = condition, y = corr, fill = condition), notch = T, width = .5) + 
            theme_bw() + xlab("") + 
            scale_fill_manual(values = setNames(unique(intgroup.dt[, hue]), 
                                                nm = unique(intgroup.dt[, condition])),
                              guide = FALSE) +
            ylab("Correlation") + ggtitle("Correlation\ndistribution") + 
            theme(plot.title = element_text(hjust = 0.5))
        
        non.na.cors.by.cond <- 
            circrna_gene_xpr_by_cond_corr[, .(pos_corr = ifelse(corr > 0, 
                                                                "Positive", "Negative"), 
                                              corr, condition)][!is.na(corr)]
        
        if(length(non.na.cors.by.cond$pos_corr) == 0){
            non.na.cors.by.cond <- 
                as.data.table(list(pos_corr = rep(c("Positive", "Negative"), 
                                                  intgroup.dt[, .N, by = condition][, .N]), 
                                   corr = rep(c(NA, NA), intgroup.dt[, .N, by = condition][, .N]), 
                                   condition = unique(intgroup.dt[, condition])))
        }
        
        cor.abs.by.cond.boxplot <- ggplot(data = non.na.cors.by.cond) +
            geom_boxplot(aes(x = condition, y = abs(corr), fill = condition), notch = T, varwidth = T)  +
            facet_wrap(facets = ~ pos_corr) + 
            scale_fill_manual(values = setNames(unique(intgroup.dt[, hue]), 
                                                nm = unique(intgroup.dt[, condition])),
                              guide = FALSE) + 
            theme_bw() + guides(fill = FALSE) + xlab("") + ylab("Abs(correlation)") +
            ggtitle("Absolute negative and positive\ncorrelation distributions") +
            theme(plot.title = element_text(hjust = 0.5))
        
        multiplot(cor.by.cond.boxplot, cor.abs.by.cond.boxplot, cols = 2)
    }
}
```

# Session info

This page was generated with the following packages version

```{r session, echo=FALSE}
sessionInfo()
```
